---
title: "MN_Flat_File_Aggregation"
author: "Holly Kundel & Mike Verhoeven"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---
# Preamble
updated 11/29
To Do:
1. New dataset from Corey (in response to missing structure data in ages)
2. add obs id for linking to Hulk data
3. Historical WAE survey duplications
4. Make sure all cols match the column names and descriptions thing





libraries
```{r}
library(arrow)
library(readr)
library(tidyverse)
library(stringr)
library(data.table)
library(janitor)
library(tidyr)
library(lubridate)
library(bit64)
library(ggplot2)
library(mwlaxeref)

options(scipen = 999)
```

Update 15 Sep 2023

We recieved a new data rip from MN DNR in three pieces: effort, catch, and cpue. Why catch and CPUE you ask? Because the DNR tells me that there are historical surveys (pre ~1985) that have CPUEs but no data for the indiv fish caught in those surveys. 


# Load Data

* note depending on your local settings, file paths need correction to match local GDrive letter
* loop not breaking when last file has name issues (adjust locations of the confirmation messages)

```{r}

files_list <- list.files(path = "E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/MN_Data/mn_raw_disaggregated_data", pattern = ".+\\.csv") #grabs only.csv files
files_list

n <- length(files_list)

for(i in 1:n) {
  #i = 3
  filei <- word(gsub(".csv","", files_list[i]), start = -1, sep = fixed("/"))
  #this does those two steps in one package
  assign(filei ,
          fread(paste0("E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/MN_Data/mn_raw_disaggregated_data/",
                                          files_list[i])))
  
  # note we want to review a sorted list of column names to check misspelling etc.
  # we still need to use the columns with names like col_name_length_in, or known_units
  
  
  cde %>% # call data explainer file
    filter(`new_file_name`== filei)%>% #keep only the row relevant to this file
    select_if(~ !any(is.na(.))) %>% 
    transpose(keep.names = "newname") %>% 
    rename("oldname" = V1) %>% 
    assign("names", ., envir = .GlobalEnv)
  
  #see if any column names will not have a match! 
  # IF any pop FALSE, force stop and revist of data explainer ()
  # - e.g., named something "total catch" when actual column name was "total_catch"
  print(
    cbind(colnames(get(filei)),
          colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]
    )
  )
  
  #this line is where the warnings are coming from
  # break the loop if the current file has column names not in the data explainer
  if (all(cbind(colnames(get(filei)),  colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ])[,2]) == FALSE ) break
  
  # append old col names into new "notes" columns:
  get(filei)[ , (names[ str_detect(newname, "notes") , oldname   ,  ]) := Map(paste, colnames(.SD), .SD, sep = ':') , .SDcols =  names[ str_detect(newname, "notes") , oldname   ,  ] ]
  
  #now rename that file's colnames
  setnames(get(filei), colnames(get(filei)), names[!str_detect(newname,"unique_row_key")] [match(names(get(filei)),names[!str_detect(newname,"unique_row_key"),oldname]), newname] )
  
  #append all other data from data explainer
  unusedbits <- 
    data.table(
      matrix(
        rep(names[ !newname %in% colnames(get(filei)) , oldname , ],
            each = nrow(get(filei))
        ),
        nrow = nrow(get(filei)),
        dimnames = list(rep(NA,nrow(get(filei))),
                        names[ !newname %in% colnames(get(filei)) , newname , ])
        )
      )
  
  #add all not yet used columns from data explainer:
  get(filei)[ , (names[ !newname %in% colnames(get(filei)) , newname , ]) := unusedbits[] ]

  #confirm import of files:  
  print(paste(filei ,"added to workspace" ))  
  
} 

#generate a file list to import
files_list <- list.files(path = "E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/MN_Data/mn_raw_disaggregated_data", pattern = ".+\\.csv") #grabs only.csv files
files_list

#object for use in loop (simple length of file list)
n <- length(files_list)

for(i in 1:n) {
  #i = 3
  filei <- word(gsub(".csv","", files_list[i]), start = -1, sep = fixed("/"))
  #this does those two steps in one package
  assign(filei ,
          fread(paste0("E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/MN_Data/mn_raw_disaggregated_data/",
                                          files_list[i])))
  
  # if the file is a crosswalk, do not rename anything, just loop to the confirm import line
  if(str_detect(filei, "crosswalk")) {  #confirm import of files:  
    print(paste(filei ,"added to workspace" ))  
    #confirm import of files:  
    print(paste(i ,"files added to workspace" )) ; next}
  
  
  # note we want to review a sorted list of column names to check misspelling etc.
  # we still need to use the columns with names like col_name_length_in, or known_units
  
  
  cde %>% # call data explainer file
    filter(`new_file_name`== filei)%>% #keep only the row relevant to this file
    select_if(~ !any(is.na(.))) %>% 
    data.table::transpose(keep.names = "newname") %>% 
    rename("oldname" = V1) %>% 
    assign("names", ., envir = .GlobalEnv)
  
  #see if any column names will not have a match! 
  # IF any pop FALSE, force stop and revist of data explainer ()
  # - e.g., named something "total catch" when actual column name was "total_catch"
  print(
    cbind(colnames(get(filei)),
          colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]
    )
  )
  
  
  # break the loop if the current file has column names not in the data explainer
  # if (all(cbind(colnames(get(filei)),  colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ])[,2]) == FALSE ) break
  if (all(colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]) == FALSE ) break
  
  
  # append old col names into new "notes" columns:
  get(filei)[ , (names[ str_detect(newname, "notes") , oldname   ,  ]) := Map(paste, colnames(.SD), .SD, sep = ':') , .SDcols =  names[ str_detect(newname, "notes") , oldname   ,  ] ]
  
  #now rename that file's colnames
  setnames(get(filei), colnames(get(filei)), names[!str_detect(newname,"unique_row_key")] [match(names(get(filei)),names[!str_detect(newname,"unique_row_key"),oldname]), newname] )
  
  #append all other data from data explainer
  unusedbits <- 
    data.table(
      matrix(
        rep(names[ !newname %in% colnames(get(filei)) , oldname , ],
            each = nrow(get(filei))
        ),
        nrow = nrow(get(filei)),
        dimnames = list(rep(NA,nrow(get(filei))),
                        names[ !newname %in% colnames(get(filei)) , newname , ])
        )
      )
  
  #add all not yet used columns from data explainer:
  get(filei)[ , (names[ !newname %in% colnames(get(filei)) , newname , ]) := unusedbits[] ]

  rm(names, unusedbits)
  
  #confirm import of files:  
  print(paste(filei ,"added to workspace" ))  
  #confirm import of files:  
  print(paste(i ,"files added to workspace" )) 

  
} 
  #confirm import of files:  
  print(paste(i ,"files added to workspace" ))
  #confirm import of files:  
  print(paste(n-i ,"remaining to be added" )) 

```


# Effort

```{r}

# effort dataset has a unique key in the combo of (lake_id, date.2(survey date), gear, survey type)
mn_effort_18aug2023[          , .N , .(lake_id, date.1, sampling_method, survey_type.1) ]

#note that there is a component count column in here that seems like it's related to effort, but not exactly clear to me:
mn_effort_18aug2023[ , summary(as.numeric(gsub("COMPONENT_COUNT:","",gear_data_notes.2))) ,]
mn_effort_18aug2023[ , hist(as.numeric(gsub("COMPONENT_COUNT:","",gear_data_notes.2)), breaks = 100) ,]


# we have two total effort cols, one is EF seconds, which I think is redundant to the main effort column:
mn_effort_18aug2023[ , total_effort_2 := gsub("EF_SECONDS:", "" , total_effort_2), ]
mn_effort_18aug2023[ total_effort_2 == "NA" , total_effort_2 := NA  ,]
mn_effort_18aug2023[  , total_effort_2 := as.numeric(total_effort_2) ,]


mn_effort_18aug2023[ , .N , .(is.na(total_effort_2), is.na(total_effort_1.1))] # any cases where all dat in total.effort.2

#here we can see that ef time is essentially covered by the total effeort 1 column (and probably more complete in that column)
plot(mn_effort_18aug2023[ !is.na(total_effort_2) , total_effort_2,]/3600~ mn_effort_18aug2023[ !is.na(total_effort_2) , total_effort_1.1 ,])
#what about the one's where they don't jive?
mn_effort_18aug2023[ round(total_effort_2/3600, 2) != total_effort_1.1, plot(total_effort_2/3600~total_effort_1.1), ]
abline(0,1)

#we don't need that extra total eff column
mn_effort_18aug2023[ , total_effort_2 := NULL , ]

#the DNR sent along two values for counts, one where they count only cases where CPUE was marked yes in the indiv fish data and one count including only where cpue was marked no in the indiv fish data

mn_effort_18aug2023[total_count.2>0 , .(total_count.1,total_count.2) , ]
mn_effort_18aug2023[ , plot(total_count.1~total_count.2) , ]

#are there any effort data with NO associated count (i.e., nothing caught)? 
mn_effort_18aug2023[   , .N , .(total_count.1 == 0, total_count.2 == 0) ]
#NOPE

#Thus, because these data are gear level, this is agg'd across species so relatively useless.

#drop these columns
mn_effort_18aug2023[ , `:=` ("total_count.1" = NULL,"total_count.2" = NULL) , ]


#fix up dates
mn_effort_18aug2023[ , date_clean :=  as.IDate(word(date.1, 1, sep = fixed(" ")), format = "%m/%d/%Y"),]
mn_effort_18aug2023[ is.na(date_clean), ]

mn_effort_18aug2023[ , hist(yday(date_clean)) ,]
mn_effort_18aug2023[ , hist(year(date_clean)) ,]

#check other fields
names(mn_effort_18aug2023)


#tidy sampling methods
mn_effort_18aug2023[ , .N , sampling_method ]
mn_effort_18aug2023[ , .N , .(sampling_method, sampling_method_abbrev)]

#keep the abbreviation/code column because that's the only thing in the CPUE file
mn_effort_18aug2023[ , .N , sampling_method_abbrev , ]
mn_cpue_21aug2023[ , .N , sampling_method_abbrev]

any(is.na(match(mn_effort_18aug2023[ , unique(sampling_method_abbrev),], mn_cpue_21aug2023[ , unique(sampling_method_abbrev) , ])))
#all abbreviations are covered (we could come back to that to add full gears to the cpues)

sort(names(mn_effort_18aug2023))

#year
mn_effort_18aug2023[ , unique(year) , ]
mn_effort_18aug2023[ is.na(year),]
 sum(mn_effort_18aug2023[ ,year != year(date_clean)])
#non-issue, delete year column
 
mn_effort_18aug2023[ , year := NULL] 
 

#effort units
mn_effort_18aug2023[ , .N , sampling_method ]


mn_effort_18aug2023[ , summary(total_effort_1.1) ,]

mn_effort_18aug2023[ total_effort_1.1 <0 , , ]

ggplot( mn_effort_18aug2023[!total_effort_1.1 < 0 ], aes(total_effort_1.1, group = sampling_method))+
  geom_density()+
  facet_wrap(~sampling_method, scales = "free")

# we can get units for these effort data from here (p45ish):
# https://files.dnr.state.mn.us/publications/fisheries/special_reports/180.pdf




```



# CPUE 2(3) ways
We have CPUE directly form the DNR, we can generate our own cpue using the individual fish data (both including and excluding the fish marked for CPUE inclusion)

```{r}

  #cpue data
  mn_cpue_21aug2023[  , .N , .(lake_id, date.1, sampling_method_abbrev, survey_type.1, species.1) ]
  sum(duplicated(mn_cpue_21aug2023))
  #not really sure why there would be duplicated cpues in there... 
  mn_cpue_21aug2023[duplicated(mn_cpue_21aug2023) , .N, .(lake_name.1, lake_id, date.1) ]
  #if these cpues are calc'd per net or instance, that could cause it. how many of each gear in each survey?
  mn_cpue_21aug2023[ , .N, .(lake_name.1, lake_id, date.1, species.1, sampling_method_abbrev) ][, summary(N)]
  mn_cpue_21aug2023[ ,mean(total_effort_1.1), .(sampling_method_abbrev) ]
  mn_cpue_21aug2023[ , .N, .(lake_name.1, lake_id, date.1, species.1, sampling_method_abbrev) ][N>1, ]

  #not likely a problem. I think sometimes multiple rows are reported for a given gear on a survey, when the catch is == between two of them you get an aparrent "duplicate"
  
  #we'll be circling back to this dataset as a way to get the historical un-lengthed fish data into our fish-obs-as-rows format
  
  
  #fix up dates
  mn_cpue_21aug2023[ , date_clean :=  as.IDate(date.1),]
  mn_cpue_21aug2023[ is.na(date_clean), ]

  mn_cpue_21aug2023[ , hist(yday(date_clean)) ,]
  mn_cpue_21aug2023[ , hist(year(date_clean)) ,]
  
  
  #check overlap betweek effort and CPUE:
  mn_cpue_21aug2023[            , .N , .(lake_id, date.1, sampling_method_abbrev, survey_type.1) ]
  mn_effort_18aug2023[          , .N , .(lake_id, date.1, sampling_method_abbrev, survey_type.1) ]

   mn_cpue_21aug2023[            , .N , .(lake_id, date_clean, sampling_method_abbrev, survey_type.1) ][
     mn_effort_18aug2023[          , .N , .(lake_id, date_clean, sampling_method_abbrev, survey_type.1) ], 
     on = .(lake_id, date_clean, sampling_method_abbrev, survey_type.1) , 
   ]
  
  # Awesome-- the effort data are entirely contained in the cpue file. So here's a plan: 
   # 1. we use the fish obs and effort to set up our obs level file
   #  2a. Identify CPUE rows unmatched in the obs level surveys (for which we have nothing in effort or indiv fish). 
   #  2b. expand those rows into obs level format (but no wieghts or lengths)
   #  2c. bring them back to that main obs level file
  
```


# Prep & Scope Indiv Fish Data

```{r}

#inspect data
colnames(mn_indiv_fish_23aug2023)
sort(colnames(mn_indiv_fish_23aug2023))

setcolorder(mn_indiv_fish_23aug2023, c("lake_id", "date.2", "date.1", "sampling_method_abbrev", "survey_type.1")) 

mn_indiv_fish_23aug2023[ , .N , .(sampling_method_abbrev, species.1)  ]
mn_indiv_fish_23aug2023[ species.1 == "WAE", .N , .(sampling_method_abbrev)  ] 
mn_indiv_fish_23aug2023[ species.1 == "WAE", .N , .(sampling_method_abbrev)  ][ , sum(N) , ]

#to-do:
# make these clean: "lake_id", "date_clean", "sampling_method", "survey_type.1"

#dates (from data explainer we know that date.2 is survey date, we prob want to join on that one to connect to the effort data)
mn_indiv_fish_23aug2023[ , .(date.2, date.1), ]
mn_indiv_fish_23aug2023[ , .N , .(date1=is.na(date.1), date2=is.na(date.2)) ]

#change dates to Idate:
mn_indiv_fish_23aug2023[ , date_clean := as.IDate(date.2, format = "%m/%d/%Y") ,]

mn_indiv_fish_23aug2023[ , summary(date_clean) , ]
mn_indiv_fish_23aug2023[is.na(date_clean) , .N ]
#no missingness!


#lake_id
mn_indiv_fish_23aug2023[ , summary(lake_id) ,]
mn_indiv_fish_23aug2023[ , str(lake_id), ]
mn_effort_18aug2023[ , str(lake_id) ,]
#no issues here


#tidy sampling methods
mn_indiv_fish_23aug2023[ , .N , .(sampling_method_abbrev)]
mn_effort_18aug2023[ , .N , .(sampling_method, sampling_method_abbrev)]


any(is.na(match(mn_effort_18aug2023[ , unique(sampling_method_abbrev),], mn_indiv_fish_23aug2023[ , unique(sampling_method_abbrev) , ])))
#all abbreviations are covered (we could come back to that to add full gears to the indiv fish, but that'll hapen in the merge, so skipped here. )



#survey.type
mn_indiv_fish_23aug2023[ , .N , survey_type.1 ]
mn_effort_18aug2023[ , .N , survey_type.1]

mn_indiv_fish_23aug2023[ , .N , survey_type.1 ][ ,survey_type.1 , ]


# generate a type table (these codes can be found in MN_Data folder)
survey_type <- data.table(code = mn_indiv_fish_23aug2023[ , .N , survey_type.1 ][ ,survey_type.1],
                          fullname = mn_effort_18aug2023[ , .N , survey_type.1][ ,survey_type.1 ][c(6,2,4,5,8,7,13,9,1,11,10,3,12,14) ]
)

#save to file
# fwrite(survey_type, file = "Data_and_Scripts\\Data\\output\\mn_survey_type_code_key.csv")

#execute
any(is.na(match(mn_indiv_fish_23aug2023[ , survey_type.1], survey_type[,code])))
survey_type[match(mn_indiv_fish_23aug2023[ , survey_type.1], survey_type[,code]), fullname]

mn_indiv_fish_23aug2023[ , survey_type.1 := survey_type[match(mn_indiv_fish_23aug2023[ , survey_type.1], survey_type[,code]), fullname]   ,]
rm(survey_type)

#uncount indiv_fish
mn_indiv_fish_23aug2023[, summary(total_count.1) , ]
mn_indiv_fish_23aug2023[total_count.1 == 0 , .N , ]

#expected result size:
mn_indiv_fish_23aug2023[ , sum(total_count.1) , ] + mn_indiv_fish_23aug2023[total_count.1 == 0 , .N , ]


#execute dataset expansion/uncount
mn_indiv_fish_23aug2023 <- 
rbind(
  mn_indiv_fish_23aug2023[total_count.1 == 0 , , ], 
  uncount(mn_indiv_fish_23aug2023, weights = total_count.1, .remove = F)
)



#summarize ages
mn_indiv_fish_23aug2023[ , .N , age ]
mn_indiv_fish_23aug2023[ , .N , .(age=!is.na(age))]


```



# Merge effort and indiv fish

```{r}
#merge the effort and indiv fish data


#scope the merge:
#99% of the wb in the effort data are represneted in indiv fish data
sum(mn_indiv_fish_23aug2023[ , unique(lake_id) , ] %in% mn_effort_18aug2023[ , unique(lake_id)])/mn_effort_18aug2023[, length(unique(lake_id)) ,] 

#100% of the wb in the indiv fish data are represneted in  effort data
sum(mn_indiv_fish_23aug2023[ , unique(lake_id) , ] %in% mn_effort_18aug2023[ , unique(lake_id)])/mn_indiv_fish_23aug2023[, length(unique(lake_id)) ,] 

#merge the effort and indiv fish data

intersect(names(mn_effort_18aug2023), names(mn_indiv_fish_23aug2023))


#we know that dates are a problem, can we schmooze that join?
#we leave many column names out of this mereg to avoid disconnecting things where one dataset has empty info
flatfish <- merge(mn_effort_18aug2023,mn_indiv_fish_23aug2023, by = c("lake_id", "date_clean" , "sampling_method_abbrev", "survey_type.1"), suffixes = c("_effort", "_indivfish"), all = T)

flatfish[ , .N , sampling_method]
flatfish[ , .N, species.1]

flatfish[ (species.1 == "WAE" & sampling_method %in% c("Standard gill net sets")), .N, .(year = year(date_clean), age = !is.na(age), length = !is.na(length.1))][order(year, -N)]


#this chunk is what Mike thinks GH wants for today
names(flatfish)

#how many unique surveys exist for each category of has effort and has indiv fish data?
flatfish[ , length(unique(paste(lake_id, date_clean , sampling_method, survey_type.1))) , .(effort = !is.na(state_effort), indiv_fish_dat = !is.na(state_indivfish)) ]
  
#sum of all
  flatfish[ , length(unique(paste(lake_id, date_clean , sampling_method, survey_type.1))) , .(effort = !is.na(state_effort), indiv_fish_dat = !is.na(state_indivfish)) ][ , sum(V1) , ]

rm(mn_indiv_fish_23aug2023,mn_effort_18aug2023)
  
  
#now roll the catch CPUE data back to this bigger file:

   mn_cpue_21aug2023[ 
     flatfish[          , .N , .(lake_id, date_clean, sampling_method_abbrev, survey_type.1) ], 
     on = .(lake_id, date_clean, sampling_method_abbrev, survey_type.1) , 
   ]
  
  mn_cpue_21aug2023[is.na(surveyXgear_indfish) , .N]
  
  #trim to only the not already covered data:
  mn_cpue_21aug2023 <- mn_cpue_21aug2023[is.na(surveyXgear_indfish) , ]
  
  mn_cpue_21aug2023[ , summary(total_count.1) , ]
  
  #execute dataset expansion/uncount
mn_cpue_21aug2023 <- 
rbind(
  mn_cpue_21aug2023[total_count.1 == 0 , , ], 
  uncount(mn_cpue_21aug2023, weights = total_count.1, .remove = F)
)

names(flatfish)


  #now bring that together with the flatfish data:
  flatfish <- rbindlist(list(flatfish, mn_cpue_21aug2023 ),
                               fill = TRUE,
                               use.names = TRUE)
  
  
  
  #for each of those with both effort and fish data, summarize catch by species (bring effort along too!)   
flatfish[ !is.na(state_effort)&!is.na(state_indivfish) , .N , .(lake_id, date_clean , sampling_method, survey_type.1, species.1, total_effort_1.1, effort_units.1) ]




#save to disk:

# saveRDS(mn_cpue_21aug2023, file = "Data_and_Scripts\\Data\\output\\mn_hist_data_flat.rds")
# saveRDS(flatfish, file = "Data_and_Scripts\\Data\\output\\mn_flat_effort_indivfish_merge.rds")


#this flatfish file is big AF and will slow down Mike's Hansen Lab Computer (32gb RAM)
flatfish <- readRDS("Data_and_Scripts\\Data\\output\\mn_flat_effort_indivfish_merge.rds")






```

# Save Parquet

```{r}


write_dataset(dataset = flatfish, path = "Data_and_Scripts/Data/output/mn_file_arrow")

mn_data <- open_dataset(sources = "Data_and_Scripts/Data/output/mn_file_arrow/")
mn_data <- open_dataset(sources = "Data_and_Scripts\\Data\\output\\mn_file_arrow\\")

glimpse(mn_data)

```



#Tidy up dataframe
```{r}
# required columns: 
# 
# 
# mn_data %>% 
#   select(contains("target")  )


mn_dat <- mn_data %>% 
  select(
    state, state_effort, state_indivfish,
    county_effort, county_indivfish,
    lake_id,
    lake_name.1, lake_name.1_effort, lake_name.1_indivfish,
    date_clean, date.1_effort, date.2_effort, end_date, date.2_indivfish, date.1_indivfish, date.1,
    survey_type.1,
    survey_id, survey_id_effort, survey_id_indivfish,
    sampling_method, sampling_method_abbrev,
    target_species,
    total_effort_1.1,
    species.1,
    length.1, length_unit.1,
    weight.1, weight_unit.1,
    sample_id.1,
    age, aging_structure, young_of_year, sex,
    original_file_name.1_effort,original_file_name.1_indivfish, original_file_name.1
  ) %>%
  collect() %>% 
  setDT()#set as data.table


#gear full names need filling out
    #show problem
    # mn_dat %>% 
    #   group_by(sampling_method_abbrev, sampling_method) %>% 
    #   summarize(n = n()) %>% 
    #   collect() %>% 
    #   print(n = nrow(.)) #everyone has data in sampling method abbrev
    # in DT
    mn_dat[ , .N , .(sampling_method_abbrev, sampling_method)]
    
    #borrow codes as key from other rows
    # gear_table_mn <- mn_dat %>% 
    #   filter(!is.na(sampling_method)) %>%
    #   select( sampling_method_abbrev, sampling_method) %>% 
    #   unique()
    # in DT
    gear_table_mn <- mn_dat[!is.na(sampling_method), .N , .(sampling_method_abbrev,sampling_method) ]
    
    
    #apply these to all rows
    # mn_dat <- mn_dat %>% 
    #   select(!sampling_method) %>% 
    #   inner_join(. , gear_table_mn, by = "sampling_method_abbrev") 
    # in DT
    #drop old col
    mn_dat[ , sampling_method := NULL ,]
    #rejoin to complete gear table
    mn_dat[gear_table_mn,
      on = .(sampling_method_abbrev), sampling_method := sampling_method
          ]
    #checkwork
    mn_dat[ , .N , .(sampling_method_abbrev, sampling_method)]
   
    
#add nothing_caught
    mn_dat[is.na(species.1), nothing_caught := T , ] #THIS NEED VERIFICATION AGAINST CODE ABOVE
     
    
#species names are mixed codes and names
    #what cols are have species in name?
    mn_dat %>%
      select(contains("species"))
    #show problem
    # mn_dat %>% 
    #   group_by(species.1) %>% 
    #   summarise(n = n()) %>% 
    #   # collect() %>% 
    #   print(n = nrow(.))
    mn_dat[ , .N , species.1 ]
    
    # Review "codes" as defined by 3 letter species names
    print(mn_dat[nchar(species.1) == 3, .N , species.1 ],
          nrow(mn_dat[nchar(species.1) == 3, .N , species.1 ]))
    
    # choose only species.1 length of 3, assign these to a species_code
    mn_dat[nchar(species.1) == 3, `:=` (species_abbrev = species.1, species.1 = NA) , ]
    
    
    #generate a species code table (will also use later to fix target species cols)    
      species_codes_mn <-  mn_dat[!is.na(species_abbrev), .(species_abbrev = unique(species_abbrev)) ,  ] 
    
    #adds names to that table (uses key provided by Jon Hansen, MNDNR on 10 Oct 2023: https://docs.google.com/spreadsheets/d/1ZakE4S2zfSdYNEWHfikFqILNnD1gYpNf?rtpof=true&usp=drive_fs )    
        #This chunk cleans codes and names within the species column, references? for codes?
      species_codes_mn[ , species.1 := 
                          case_when(# first fish codes are converted,
                            species_abbrev == "LMB" ~ "largemouth_bass",
                            species_abbrev == "SMB" ~ "smallmouth_bass",
                            species_abbrev == "WAE" ~ "walleye", 
                            species_abbrev == "WTS" ~ "white_sucker",
                            species_abbrev == "BLC" ~ "black_crappie",
                            species_abbrev == "YEP" ~ "yellow_perch",
                            species_abbrev == "BLG" ~ "bluegill",
                            species_abbrev == "NOP" ~ "northern_pike",
                            species_abbrev == "PMK" ~ "pumpkinseed", 
                            species_abbrev == "RKB" ~ "rock_bass",
                            species_abbrev == "BKF" ~ "banded_killifish",
                            species_abbrev == "IOD" ~ "iowa_darter",
                            species_abbrev == "BCS" ~ "blackchin_shiner",
                            species_abbrev == "BLB" ~ "black_bullhead",
                            species_abbrev == "JND" ~ "johnny_darter",
                            species_abbrev == "GOS" ~ "golden_shiner",
                            species_abbrev == "YEB" ~ "yellow_bullhead",
                            species_abbrev == "BRB" ~ "brown_bullhead",
                            species_abbrev == "CNM" ~ "central_mudminnow",
                            species_abbrev == "NRD" ~ "northern_redbelly_dace",
                            species_abbrev == "CSH" ~ "chinook_salmon",
                            species_abbrev == "MTS" ~ "mottled_sculpin",
                            species_abbrev == "TPM" ~ "tadpole_madtom",
                            species_abbrev == "SHR" ~ "shorthead_redhorse",
                            species_abbrev == "HSF" ~ "hybrid_sunfish",
                            species_abbrev == "BOF" ~ "bowfin",
                            species_abbrev == "WDS" ~ "weed_shiner",
                            species_abbrev == "BNM" ~ "bluntnose_minnow",
                            species_abbrev == "BND" ~ "blacknose_dace",
                            species_abbrev == "OTM" ~ "minnows",
                            species_abbrev == "FHM" ~ "fathead_minnow",
                            species_abbrev == "FND" ~ "finescale_dace",
                            species_abbrev == "SDM" ~ "slender_madtom",
                            species_abbrev == "SPO" ~ "spottail_shiner",
                            species_abbrev == "BNS" ~ "blacknose_shiner",
                            species_abbrev == "BKT" ~ "brook_trout",
                            species_abbrev == "SPT" ~ "splake",
                            species_abbrev == "RBT" ~ "rainbow_trout",
                            species_abbrev == "BNT" ~ "brown_trout",
                            species_abbrev == "BUB" ~ "burbot",
                            species_abbrev == "BIB" ~ "bigmouth_buffalo",
                            species_abbrev == "BLH" ~ "bullheads",
                            species_abbrev == "TLC" ~ "cisco",
                            species_abbrev == "CCF" ~ "channel_catfish",
                            species_abbrev == "BSD" ~ "blackside_darter",
                            species_abbrev == "BKS" ~ "brook_silverside",
                            species_abbrev == "LED" ~ "least_darter",
                            species_abbrev == "LGP" ~ "logperch",
                            species_abbrev == "SLR" ~ "silver_redhorse",
                            species_abbrev == "HHC" ~ "hornyhead_chub",
                            species_abbrev == "MUE" ~ "muskellunge",
                            species_abbrev == "TRP" ~ "trout_perch",
                            species_abbrev == "RHS" ~ "redhorse",
                            species_abbrev == "CAP" ~ "common_carp",
                            species_abbrev == "MMS" ~ "mimic_shiner",
                            species_abbrev == "EMS" ~ "emerald_shiner",
                            species_abbrev == "SUN" ~ "sunfish",
                            species_abbrev == "CRC" ~ "creek_chub",
                            species_abbrev == "GSF" ~ "green_sunfish",
                            species_abbrev == "SFS" ~ "spotfin_shiner",
                            species_abbrev == "SHI" ~ "shiners",
                            species_abbrev == "BST" ~ "brook_stickleback",
                            species_abbrev == "CSR" ~ "central_stoneroller",
                            species_abbrev == "SDS" ~ "sand_shiner",
                            species_abbrev == "GRR" ~ "greater_redhorse",
                            species_abbrev == "PGS" ~ "pugnose_shiner",
                            species_abbrev == "SMS" ~ "slimy_sculpin",
                            species_abbrev == "LND" ~ "longnose_dace",
                            species_abbrev == "FRD" ~ "freshwater_drum",
                            species_abbrev == "WHC" ~ "white_crappie",
                            species_abbrev == "DAR" ~ "darters",
                            species_abbrev == "SAR" ~ "sauger",
                            species_abbrev == "FCF" ~ "flathead_catfish",
                            species_abbrev == "BMS" ~ "bigmouth_shiner",
                            species_abbrev == "LKS" ~ "lake_sturgeon",
                            species_abbrev == "LKW" ~ "lake_whitefish",
                            species_abbrev == "BRM" ~ "brassy_minnow",
                            species_abbrev == "SLM" ~ "mississippi_silvery_minnow",
                            species_abbrev == "GLR" ~ "golden_redhorse",
                            species_abbrev == "OTS" ~ "suckers",
                            species_abbrev == "NST" ~ "ninespine_stickleback",
                            species_abbrev == "GOE" ~ "goldeye",
                            species_abbrev == "QBS" ~ "quillback",
                            species_abbrev == "RVS" ~ "river_shiner",
                            species_abbrev == "LES" ~ "longear_sunfish",
                            species_abbrev == "CHL" ~ "chestnut_lamprey",
                            species_abbrev == "RRH" ~ "river_redhorse",
                            species_abbrev == "WHB" ~ "white_bass",
                            species_abbrev == "OSS" ~ "orangespotted_sunfish",
                            species_abbrev == "STC" ~ "stonecat",
                            species_abbrev == "SNG" ~ "shortnose_gar",
                            species_abbrev == "RFS" ~ "rosyface_shiner",
                            species_abbrev == "CMS" ~ "carmine_shiner",
                            species_abbrev == "SAB" ~ "smallmouth_buffalo",
                            species_abbrev == "GIS" ~ "gizzard_shad",
                            species_abbrev == "LNG" ~ "longnose_gar",
                            species_abbrev == "RCS" ~ "river_carpsucker",
                            species_abbrev == "SLS" ~ "shovelnose_sturgeon",
                            species_abbrev == "LAT" ~ "lake_trout",
                            species_abbrev == "TME" ~ "tiger_muskellunge",
                            species_abbrev == "PRD" ~ "pearl_dace",
                            species_abbrev == "PLS" ~ "pallid_shiner",
                            species_abbrev == "RBS" ~ "rainbow_smelt",
                            species_abbrev == "RBD" ~ "rainbow_darter",
                            species_abbrev == "LNS" ~ "longnose_sucker",
                            species_abbrev == "SJC" ~ "shortjaw_cisco",
                            species_abbrev == "DWS" ~ "deepwater_sculpin",
                            species_abbrev == "SHS" ~ "spoonhead_sculpin",
                            species_abbrev == "BDD" ~ "banded_darter",
                            species_abbrev == "MOE" ~ "mooneye",
                            species_abbrev == "BLS" ~ "blue_sucker",
                            species_abbrev == "SLC" ~ "silver_chub",
                            species_abbrev == "HFS" ~ "highfin_carpsucker",
                            species_abbrev == "MCP" ~ "mirror_carp",
                            species_abbrev == "WAS" ~ "walleye/sauger",
                            species_abbrev == "AME" ~ "american_eel",
                            species_abbrev == "GOF" ~ "goldfish",
                            species_abbrev == "SPS" ~ "spotted_sucker",
                            species_abbrev == "PAH" ~ "paddlefish",
                            species_abbrev == "RVD" ~ "river_darter",
                            species_abbrev == "NHS" ~ "northern_hog_sucker",
                            species_abbrev == "BHM" ~ "bullhead_minnow",
                            species_abbrev == "WSD" ~ "western_sand_darter",
                            species_abbrev == "MDD" ~ "mud_darter",
                            species_abbrev == "SIL" ~ "silver_lamprey",
                            species_abbrev == "SKJ" ~ "skipjack_herring",
                            species_abbrev == "PGM" ~ "pugnose_minnow",
                            species_abbrev == "BKB" ~ "black_buffalo",
                            species_abbrev == "FTD" ~ "fantail_darter",
                            species_abbrev == "YLB" ~ "yellow_bass",
                            species_abbrev == "PRP" ~ "pirate_perch",
                            species_abbrev == "LKC" ~ "lake_chub",
                            species_abbrev == "RIR" ~ "river_ruffe",
                            species_abbrev == "WHP" ~ "white_perch",
                            species_abbrev == "ALW" ~ "alewife",
                            species_abbrev == "SEL" ~ "sea_lamprey",
                            species_abbrev == "BHC" ~ "bighead_carp",
                            species_abbrev == "GLD" ~ "gilt_darter",
                            species_abbrev == "CRD" ~ "crystal_darter",
                            species_abbrev == "SMT" ~ "speckled_madtom",
                            species_abbrev == "RDS" ~ "red_shiner",
                            species_abbrev == "WAM" ~ "warmouth",
                            species_abbrev == "CIS" ~ "cisco",
                            species_abbrev == "CPS" ~ "carpsucker",
                            species_abbrev == "CRP" ~ "crappie",
                            species_abbrev == "HCR" ~ "hybrid_crappie",
                            species_abbrev == "SCU" ~ "sculpin",
                            species_abbrev == "SHD" ~ "slenderhead_darter",
                            species_abbrev == "SIP" ~ "northern_pike_silver_phase",
                            species_abbrev == "UK1" ~ "unknown_fish",
                            species_abbrev == "UK2" ~ "unknown_fish",
                            # below unknown codes specified as such
                            species_abbrev == "LXB" ~ "see_ambiguous_species_code",
                            TRUE ~ species_abbrev
                          )
      ]
      
      #some dulicated common names (two codes for one thing)
      species_codes_mn[duplicated(species_codes_mn$species.1), , ]
      
      setnames(species_codes_mn, "species.1" , "common.name" )
      
        #fill species names
      mn_dat[species_codes_mn,
             on = .(species_abbrev=species_abbrev),
             species.fix := common.name 
      ]
        #fill into species.1 col, drop fix column
        mn_dat[is.na(species.1), species.1 := species.fix , ]
                mn_dat[ , species.fix := NULL ,]
       
        
        #clean up common names
        mn_dat[ , species.1 := str_replace_all( str_replace_all( str_replace_all(tolower(species.1),
                                                                                 " ", "_") ,
                                                                 "\\)" , "") ,
                                                "\\(" , "")]
        
        mn_dat[ , species.1 := 
                  case_when(
                    species.1 == "tullibee_cisco" ~ "cisco",
                    species.1 == "trout-perch" ~ "trout_perch",
                    species.1 == "bowfin dogfish" ~ "bowfin",
                    # unknown species
                    species.1 == "no_particular_species" ~ "no_particular_species",
                    species.1 == "unknown_fish_one" ~ "unknown_fish",
                    species.1 == "walleye/sauger" ~ "walleye_x_sauger",
                    TRUE ~ species.1
                  )
        ]
        
        #check work
        print(mn_dat[ , .N , species.1][order(species.1)], nrow(mn_dat[ , .N , species.1])) 
        
        #still 1904 NAs here (nothing caught surveyXgears)
        mn_dat[is.na(species.1) , .N , .(nothing_caught)  ]
        
        
        #fill species codes
        species_codes_mn
        mn_dat[!is.na(species_abbrev), .N , .(species_abbrev,species.1) ]
        species_codes_mn <- mn_dat[!is.na(species_abbrev), .N , .(species_abbrev,species.1) ]
        
        setnames(species_codes_mn, "species_abbrev", "fishcode")
        
        mn_dat[species_codes_mn, on = .(species.1), species_abbrev_fix := fishcode ]
        
        mn_dat[, species_abbrev := species_abbrev_fix]
        
        #check work
        print(mn_dat[ , .N , .(species.1,species_abbrev)], nrow(mn_dat[ , .N , .(species.1,species_abbrev)]))
        
        mn_dat[ , species_abbrev_fix := NULL]

        
# fix state
       #what cols are have species in name?
    mn_dat[ , .N ,  .(state, state_effort, state_indivfish) ]
    
    #collapse all
    mn_dat[ , `:=` (state = "Minnesota", state_effort = NULL, state_indivfish = NULL) , ]
    

# fix unit names for length and age
    #formats the length unit for clarity
    mn_dat[ , .N , length_unit.1 ]
    mn_dat[ , .N , weight_unit.1]
    
    mn_dat[!is.na(length_unit.1), length_unit.1 := "mm" ,]
    mn_dat[!is.na(weight_unit.1), weight_unit.1 := "g" ,]

# target species
    #targeted species - needs cleaning, has species codes (clean up with the species code table generated above)
    mn_dat[ , .N , target_species ]
    mn_dat[ , c("T1","T2", "T3", "T4", "T5")  :=   tstrsplit(target_species, split = ", "), ]
    
    setnames(species_codes_mn, "species.1", "commonname")
    
    mn_dat[species_codes_mn, on = .(T1=fishcode) , target_species_1 := commonname ]
    mn_dat[species_codes_mn, on = .(T2=fishcode) , target_species_2 := commonname ]
    mn_dat[species_codes_mn, on = .(T3=fishcode) , target_species_3 := commonname ]
    mn_dat[species_codes_mn, on = .(T4=fishcode) , target_species_4 := commonname ]
    mn_dat[species_codes_mn, on = .(T5=fishcode) , target_species_5 := commonname ]
    
    mn_dat[ !is.na(target_species), unique(paste(target_species_1,target_species_2, target_species_3, target_species_4,target_species_5))]
    
    mn_dat[ , target_species := str_remove_all(paste(target_species_1,target_species_2, target_species_3, target_species_4,target_species_5, sep = ", "),
                                               ", NA"),]
    
    mn_dat[ , c("T1","T2", "T3", "T4", "T5",
                "target_species_1","target_species_2", "target_species_3", "target_species_4", "target_species_5") := NULL]
    
# effort needs attention. Currently we have a negative effort and no units (nab code to add units from Holly based on gear type)
    #effort
    mn_dat %>% 
      select(contains("effort"))
    #total_effort_1.1
    
    gear_table_mn[order(sampling_method_abbrev)]
    
    mn_dat[ !is.na(total_effort_1.1), .(mean = mean(total_effort_1.1), min =min(total_effort_1.1), max = max(total_effort_1.1)) , ]
    #no effort units, we have a negative effort? 
    
    # we can get units for these effort data from here (p45ish):
    # https://files.dnr.state.mn.us/publications/fisheries/special_reports/180.pdf
    #manually added the units for AOW, TMF, and GFM -- assuming same as similar gear categories
    effort_table <- data.table( CODE = c(c("AIF", "TOU", "ATL", "STL", "EXT", "XXX", "MT", "SA", "ZO", "AOW"),#NONE
                                 c("TR" , "STR", "SEF", "EFB", "EW", "EF"), #HOUR 
                                 c("SSE", "SE", "S18", "S58"), #HAUL
                                 c("GN", "GDE", "GSH", "GSM", "GST", "GSU", "GNP", "FCI", "TML", "SGN", "GNA", "VGN", "TN", "LTN", "DTN", "TQU", "T38", "THA", "T34", "T1", "STN", "GFM", "TMF")),#SET  
                        effort_unit = c(rep("no_unit", 10), rep("hours", 6), rep("haul", 4), rep("set", 23)))
    
    #add effort units to gear tbale       
    gear_table_mn[effort_table, on = .(sampling_method_abbrev=CODE), total_effort_unit := effort_unit]
    #and push those over to the main df
    mn_dat[gear_table_mn, on = .(sampling_method_abbrev), total_effort_unit := total_effort_unit]
    
    #cleanup and checkwork
    rm(effort_table)
    mn_dat[ , .N , .(sampling_method, total_effort_unit)]
    
    mn_dat[ total_effort_1.1 < 0 ] #weird, but not diagnosable/fixable IMO.
    mn_dat[ total_effort_1.1 < 0, flag := "effort value questionable" ]
    
#survey_id 
    mn_dat %>%
      select(contains("survey_"))
    
    mn_dat[ ,  .N, .(survey_id == survey_id_effort)]
    
    #something looks wonky in these survey Ids but the MNDNR says they're not useful anyways... see Minnnesota_README (https://docs.google.com/document/d/1sXag9RDvbKN0pUB6uRlADz36-kFNqRPwHVGlkJgyWTM/edit)
    
    mn_dat[ , survey_id := NULL , ]
    
    
    
   # borrowed this code from county, and it the numbers match. both county and survey ID are cases where we should just consolidate all three cols (no disagreement, outisde of NAs)
          mn_dat %>% 
            mutate(same_survID_eff_fish = ifelse(survey_id_effort == survey_id_indivfish, "Same", "Different")) %>% 
            mutate(same_survID_eff_catch = ifelse(survey_id_effort == survey_id, "Same", "Different")) %>% 
            mutate(same_survID_catch_fish = ifelse(survey_id == survey_id_indivfish, "Same", "Different")) %>% 
            group_by(same_survID_eff_fish,same_survID_eff_catch,same_survID_catch_fish) %>% 
            count()
          #no conflicting rows between effort and fish, but data might be missing from one or the other
          
          mn_dat[, .N, .(catchisNA = is.na(survey_id),
                                                                effortisNA = is.na(survey_id_effort),
                                                                fishisNA = is.na(survey_id_indivfish))
                 ]
          
          #collapse:
          mn_dat[ , survey_id := ifelse(is.na(survey_id_effort), survey_id_indivfish, survey_id_effort) , ]
          mn_dat[ , county    := ifelse(is.na(county_effort), county_indivfish, county_effort )]
          
          mn_dat[ , c("survey_id_indivfish", "survey_id_effort", "county_effort", "county_indivfish") := NULL ,]
          
          mn_dat[ , .N, gsub(".", "", as.character(survey_id))]
          
          
          

#lake_name
              mn_dat[, .N, .(catchisNA = is.na(lake_name.1),
                                                                effortisNA = is.na(lake_name.1_effort),
                                                                fishisNA = is.na(lake_name.1_indivfish))
                 ]
            mn_dat %>% 
            mutate(same_survID_eff_fish = ifelse(lake_name.1_effort == lake_name.1_indivfish, "Same", "Different")) %>% 
            mutate(same_survID_eff_catch = ifelse(lake_name.1_effort == lake_name.1, "Same", "Different")) %>% 
            mutate(same_survID_catch_fish = ifelse(lake_name.1 == lake_name.1_indivfish, "Same", "Different")) %>% 
            group_by(same_survID_eff_fish,same_survID_eff_catch,same_survID_catch_fish) %>% 
            count()
          
            mn_dat[is.na(lake_name.1), lake_name.1 := ifelse(is.na(lake_name.1_effort), lake_name.1_indivfish, lake_name.1_effort)]
              mn_dat[ , c("lake_name.1_effort","lake_name.1_indivfish") := NULL]
              
#date
              mn_dat[ , .N , is.na(date_clean)]
              setnames(mn_dat, "date.1", "date.1_histcatch")
              
              #dump all extra dates:
              mn_dat[ , c("date.1_effort", "date.2_effort", "end_date", "date.2_indivfish", "date.1_indivfish", "date.1_histcatch") := NULL, ]
              
              
# add an effort_ident column "lake_id", "date_clean" , "sampling_method_abbrev", "survey_type.1"effort_ident := .GRP
    setnames(mn_dat, "total_effort_unit", "effort_units.1")
        mn_dat[ , .N ,.(lake_id, date_clean, survey_type.1, sampling_method_abbrev  #survey 
                                                        ) ]  
    #outstanding issue here: we've got total_effort mismatched within some surveys
        mn_dat[ , length(unique(total_effort_1.1)),.( lake_id, date_clean, survey_type.1, #survey 
                        sampling_method_abbrev 
                                                        ) ][V1>1] #the offenders
        
        #view one of these:
        a <- mn_dat[date_clean == "1984-08-30" & lake_id == 35000300,  , ]

        #looks to me like those multi-efforts are true to the data. I suppose we have to assume that the data were recorded as each of those implementations of same gear being separate... Not actually sure that matters. but even so the problem exists in 22 surveyXgears of 64040... so prob not a big deal.  
        
        
        mn_dat[ , .N ,.( lake_id, date_clean, survey_type.1, #survey 
                        sampling_method_abbrev, total_effort_1.1, effort_units.1, nothing_caught 
                                                        ) ] 
        #adds in our effort_ident field
        mn_dat[ , effort_ident := .GRP ,.( lake_id, date_clean, survey_type.1, #survey 
                        sampling_method_abbrev, total_effort_1.1, effort_units.1, nothing_caught 
                                                        ) ] 
    
    
#use mwlaxeref to fetch NHDIDs
  local_to_nhdhr(mn_dat[,.(lake_id = fixlakeid(lake_id))], from_colname = "lake_id", state = "mn")[,2]
  
  mn_dat[ , nhdhr.id := local_to_nhdhr(mn_dat[,.(lake_id = fixlakeid(lake_id))], from_colname = "lake_id", state = "mn")[,2] , ]
    

  #remaining unmatched lakes:
  mn_dat[is.na(nhdhr.id), .N , lake_id ]
  

    
#get the original file names named correctly and check coverage of sources with them:
  setnames(mn_dat, "original_file_name.1", "original_file_name.1_histcatch")
  mn_dat[ , .N, .(catchNA = is.na(original_file_name.1_histcatch),
                  fishlengthNA = is.na(original_file_name.1_indivfish),
                  effortNA = is.na(original_file_name.1_effort))]
  


#   This block was used to reload the data after a pause on the work 
#   mn_dat <- mn_data %>% 
# +     select(
# +         state, county, lake_name.1, lake_id, nhdhr.id, 
# +         date_clean, date.1_effort, date.2_effort, end_date, date.2_indivfish, date.1_indivfish, date.1_histcatch,
# +         survey_type.1, survey_id, 
# +         sampling_method, sampling_method_abbrev, total_effort_1.1, effort_units.1, nothing_caught, target_species, effort_ident,
# +         species.1, species_abbrev, length.1, length_unit.1,weight.1, weight_unit.1, sample_id.1, age, aging_structure, young_of_year, sex,
# +         original_file_name.1_effort,original_file_name.1_indivfish, original_file_name.1_histcatch, flag
# +     ) %>%
# +     collect() %>% 
# +     setDT()#set as data.table
#   
  
 # adds columns needed for state filtering
  #adding lake area to the data
area <- read_csv("Data_and_Scripts/Data/input/mn_lake_list.csv") %>%
  select(DOW, LAKE_AREA_DOW_ACRES) %>%
  mutate(DOW = as.integer(DOW))
#joins fish data with area data
mn_dat <- left_join(mn_dat, area, by = c("lake_id" = "DOW")) %>%
  #hard codes lakes that do not have area in the area file (areas taken from lake finder)
  mutate(LAKE_AREA_DOW_ACRES = as.numeric(case_when(
        lake_id == "56038800" ~ "1288",
        lake_id == "55006400" ~ "20",
        lake_id == "76014601" ~ "467",
        lake_id == "76014602" ~ "218",
        TRUE ~ as.character(LAKE_AREA_DOW_ACRES)))) %>%
  #creates binned area grouping used for minimum effort calculation
  mutate(area.group = case_when(LAKE_AREA_DOW_ACRES < 100 ~ "<100",
                                LAKE_AREA_DOW_ACRES >= 100 & LAKE_AREA_DOW_ACRES <= 300 ~ "100-300",
                                LAKE_AREA_DOW_ACRES >= 301 & LAKE_AREA_DOW_ACRES <= 600 ~ "301-600",
                                LAKE_AREA_DOW_ACRES >= 601 & LAKE_AREA_DOW_ACRES <= 1500 ~ "601-1500",
                                LAKE_AREA_DOW_ACRES >= 1501 ~ "1501+",
                                TRUE ~ "NA")) %>%
  #orders groupings so they plot well
  mutate(area.group = factor(area.group, levels = c("<100", "100-300", "301-600", "601-1500", "1501+")))
  
  
  setnames(mn_dat, c("LAKE_AREA_DOW_ACRES", "area.group"), c("lake_area_dow_acres", "area_group"))
  
  
  



```


# Save Parquet

```{r}






write_dataset(dataset = mn_dat, path = "Data_and_Scripts/Data/output/mn_file_arrow")

mn_data <- open_dataset("Data_and_Scripts/Data/output/mn_file_arrow/")

glimpse(mn_data)

```

# send some data to chris

```{r}

library(arrow)
mn_data <- open_dataset("Data_and_Scripts/Data/output/mn_file_arrow/")
glimpse(mn_data)

#add more gears from this list if desired
mn_data %>% 
  group_by(sampling_method_abbrev,sampling_method) %>% 
  count() %>% 
  compute()

mn_data %>% 
  filter(sampling_method_abbrev %in% c("GN", #gill nets common type
                                "TN" # trap nets common type
                                )) %>% 
  compute()


#mccarrons lake fish

mn_data %>% 
  filter(lake_id == 62005400) %>% 
  group_by(species.1, year(date_clean), sampling_method) %>% 
  summarize(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))

#paul F reprex


data <- data.frame(dow = c(1000100, 10000200),
                   dow_chr = c("01000100", "10000200"))

mwlaxeref::lake_id_xref %>% filter(state == "mn", local.id %in% c("01000100" , "10000200"))

local_to_nhdhr(data, from_colname = "dow", state = "mn")
local_to_nhdhr(data, from_colname = "dow_chr", state = "mn")





```


#Diversity exploration
```{r}

library(vegan)

colnames(wide_complete)
wide_complete[ , 7:112 ,]

diversity(wide_complete[ , 7:112 ,], index = "invsimpson" )


wide_complete[ , invsimpson := diversity(wide_complete[ , 7:112 ,], index = "invsimpson" ) ,]

wide_complete[ , alltime_masIS:= round(max(invsimpson),0)  ,  .(lake_id, sampling_method)]
wide_complete[ , alltime_medIS:= median(invsimpson)  ,  .(lake_id, sampling_method)]



ggplot(wide_complete[sampling_method %in% c("Standard gill nets", "Standard trap nets")] , aes(year(date_clean), invsimpson)  )+
  geom_line(aes(group = lake_id))+
  facet_grid(alltime_masIS~sampling_method)+
  geom_smooth()


ggplot(data = wide_complete[ , .(var(invsimpson) , alltime_medIS), lake_id ], aes(alltime_medIS, V1))+
  geom_point()+geom_smooth()+ ylab("variance in Diversity") + xlab("alltime median Diversity")

ggplot(data = wide_complete[ , .(var(WAE/total_effort_1.1) , alltime_medIS), lake_id ], aes(alltime_medIS, V1))+
  geom_point()+geom_smooth()+ ylab("variance in walleye cpue") + xlab("alltime median Diversity")+scale_y_log10()







```
