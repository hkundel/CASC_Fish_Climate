---
title: "b_WI_Flat_File_Aggregation"
author: "Holly Kundel & Mike Verhoeven"
date: "`r Sys.Date()`"
output: html_document
---



# Outstanding work

DONE  1. Fix data import to squash warnings and add ticker
      2. Button up the column name cleaning section of the file
DONE  2b. consider a reformat to Arrow (sooner) for speed -- currently implemented at end, consider implementing this step earlier. 
      3. Add section for (minimal acceptable) data proofing
DONE  4. Lake winnebago data are not yet "uncount" ed
DUP2  5. Need to tidy up as many colnames as possible at each merge phase to prevent huge buildup of shit at the end (see current section at line 550ish)
DONE  6.Crosscheck to CPUE file provided to us to check calcs/agreement
DONE 6a. Flag abunds affected by this mismatch

# Preamble

libraries
```{r}
library(arrow)
library(readr)
library(dplyr)
library(stringr)
library(data.table)
library(janitor)
library(tidyr)
library(lubridate)
library(ggplot2)

options(scipen = 999)
```


# Load Data

* First run CASC Data Explainer
* note Holly has to change "E" in file paths to "D" 
* This data import block takes about 10 minutes to run
* needs an update to nix warnings (see Github issue on this)
```{r}
#generate a file list to import
files_list <- list.files(path = "E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data", pattern = ".+\\.csv") #grabs only.csv files
#grabs only.csv files
files_list

#object for use in loop (simple length of file list)
n <- length(files_list)

for(i in 1:n) {
  #i = 3
  filei <- word(gsub(".csv","", files_list[i]), start = -1, sep = fixed("/"))
  #this does those two steps in one package
  assign(filei ,
          fread(paste0("E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data/",
                                          files_list[i])))
  
  # if the file is a crosswalk, do not rename anything, just loop to the confirm import line
  if(str_detect(filei, "crosswalk")) {  #confirm import of files:  
    print(paste(filei ,"added to workspace" ))  
    #confirm import of files:  
    print(paste(i ,"files added to workspace" )) ; next}
  
  
  # note we want to review a sorted list of column names to check misspelling etc.
  # we still need to use the columns with names like col_name_length_in, or known_units
  
  
  cde %>% # call data explainer file
    filter(`new_file_name`== filei)%>% #keep only the row relevant to this file
    select_if(~ !any(is.na(.))) %>% 
    transpose(keep.names = "newname") %>% 
    rename("oldname" = V1) %>% 
    assign("names", ., envir = .GlobalEnv)
  
  #see if any column names will not have a match! 
  # IF any pop FALSE, force stop and revist of data explainer ()
  # - e.g., named something "total catch" when actual column name was "total_catch"
  print(
    cbind(colnames(get(filei)),
          colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]
    )
  )
  
    
  # break the loop if the current file has column names not in the data explainer
  # if (all(cbind(colnames(get(filei)),  colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ])[,2]) == FALSE ) break
  if (all(colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]) == FALSE ) break
  
  
  # append old col names into new "notes" columns:
  get(filei)[ , (names[ str_detect(newname, "notes") , oldname   ,  ]) := Map(paste, colnames(.SD), .SD, sep = ':') , .SDcols =  names[ str_detect(newname, "notes") , oldname   ,  ] ]
  
  #now rename that file's colnames
  setnames(get(filei), colnames(get(filei)), names[!str_detect(newname,"unique_row_key")] [match(names(get(filei)),names[!str_detect(newname,"unique_row_key"),oldname]), newname] )
  
  #append all other data from data explainer
  unusedbits <- 
    data.table(
      matrix(
        rep(names[ !newname %in% colnames(get(filei)) , oldname , ],
            each = nrow(get(filei))
        ),
        nrow = nrow(get(filei)),
        dimnames = list(rep(NA,nrow(get(filei))),
                        names[ !newname %in% colnames(get(filei)) , newname , ])
        )
      )
  
  #add all not yet used columns from data explainer:
  get(filei)[ , (names[ !newname %in% colnames(get(filei)) , newname , ]) := unusedbits[] ]

  #confirm import of files:  
  print(paste(filei ,"added to workspace" ))  
  #confirm import of files:  
  print(paste(i ,"files added to workspace" )) 

  
} 

  #confirm import of files:  
  print(paste(i ,"files added to workspace" ))
  #confirm import of files:  
  print(paste(n-i ,"remaining to be added" )) 

```

# Identify Which data types are in each file
[1] "wi_inland_cpue_19Mar2021.csv"                  ~ CPUE (Effort and Catch)                 
[2] "wi_inland_effort_19Mar2021.csv"                ~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)          
[3] "wi_inland_fishobservations_19Mar2021.csv"      ~ Individual Fish    
[4] "wi_inland_lenage_19Mar2021.csv"                ~ Individual Fish             
[5] "wi_winnebago_cpue_23Apr2021.csv"               ~ CPUE (just has CPUE and units for CPUE)       LINE 338 - LINE 356 shows that this file is redundant and unneeded.       
[6] "wi_winnebago_fishobservations_23April2021.csv" ~ Individual Fish NO THIS IS NOT!!!!!!!!!


# Effort Data

Inland effort data exploration ([2] "wi_inland_effort_19Mar2021.csv"~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)   )
```{r}
# Only one "True Effort" file (each row is a gear in a survey): 'wi_inland_effort_19Mar2021'

# Rest of the files with Effort also have catch (species in a gear with a survey)

# CPUE/Effort Files with Catch: "wi_inland_cpue_19Mar2021" 

# wi_winnebago_cpue_23Apr2021.csv ~ only has CPUE and CPUE units. No catch or effort
    # effort for all winnebago surveys is "5 min trawl"
    


#investigate the one true effort file we have

# gears present
wi_inland_effort_19Mar2021[ ,.N , sampling_method ]
  # 53 unique gears: electrofishing, nets, hook and line, traps, trawls, etc.

wi_inland_effort_19Mar2021[sampling_method=="seine" , ,  ][gear_data_notes.9 == "number.of.nets:NA"]

# where do actual efforts live for each type of gear
wi_inland_effort_19Mar2021[ ,.N , .(sampling_method, distance, sample_time_notes.1, gear_data_notes.9) ]
  # it appears any kind of shocking effort is in "sample_time_notes.1 and "distance"
  # net effort is in "gear_data_notes.9"

#whats this line do? 
# wi_inland_effort_19Mar2021[ ,.(sampling_method, distance, gear_data_notes.1, gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, gear_data_notes.5, gear_data_notes.6, gear_data_notes.7, gear_data_notes.8, gear_data_notes.9, gear_data_notes.10, gear_data_notes.11, gear_data_notes.12, gear_data_notes.13, sample_time_notes.1, sample_time_notes.2) , sampling_method]

#is survey_id unique to each survey?
wi_inland_effort_19Mar2021[ ,  , survey_id] # Holly E said to be cautious about survey ID #THIS LINE JUST PRINTS THE ENTIRE DATASET
  wi_inland_effort_19Mar2021[ , .N , survey_id]
    # yes! NO THE SURVEY ID IS NOT A UNIQUE KEY HERE
wi_inland_effort_19Mar2021[ ,  , .(lake_id, date.1, sampling_method)] #THIS LINE JUST PRINTS THE ENTIRE DATASET
  wi_inland_effort_19Mar2021[ , .N  , .(lake_id, date.1, sampling_method)]
  # lake_id, date.1, and sampling_method also work as a key
  #NO THEY DONT

# does "year" work as well as "date.1" ?
wi_inland_effort_19Mar2021[ , , .(lake_id, year, sampling_method)] #THIS LINE JUST PRINTS THE ENTIRE DATASET TRY THESE:
      wi_inland_effort_19Mar2021[ ,.N , .(lake_id, sampling_method)]
      wi_inland_effort_19Mar2021[ , .N , .(lake_id, year, sampling_method)]
  # for the inland data, year works just as well
      #^NOT RIGHT
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, date.1, sampling_method)]
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, year, date.1, sampling_method)] # why does year add identity to these data!?!??!
          wi_inland_effort_19Mar2021[ , unique(date.1) , ]
          wi_inland_effort_19Mar2021[ word(date.1, -1, sep = "/") != year , . (date.1, year) , ] #in the orginal data, date == "sample date", whereas year == "survey year"
          #reviewing a bit of this data suggests that there are surveys that lasted multiple years (like maybe they were mark-recpature or cohort tracking mortality estimating special surveys. Not sure TBH)
        
        
       #NEED TO VERIIFY HERE THAT THE VARIABLE VISIT.FISH.SEQ.NO is a surveyXgearID
        wi_inland_effort_19Mar2021[  , .N  , .(sample_id.1)] # so obviously this is a good key
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, survey_id, year, date.1, sampling_method)] #try to understand what makes a row (sample-wise)
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)] [ , hist(N) ,]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)] [ , summary(N) ,]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method,
                                             #gear data adds ident value to the set
                                             distance, sample_time_notes.1, sample_time_notes.2, sample_time_notes.3, 
                                             gear_data_notes.1, 
                                             gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, 
                                             gear_data_notes.5, 
                                             gear_data_notes.6, 
                                             gear_data_notes.7, 
                                             gear_data_notes.8, 
                                             gear_data_notes.9, 
                                             gear_data_notes.10, 
                                             gear_data_notes.11, 
                                             gear_data_notes.12, gear_data_notes.13, gear_data_notes.14, gear_data_notes.15)]
      # IMO this suggests that any effort data loaded into the pipeline ought to REQUIRE an input (allow many?) of total effort. 
      # gear_data_notes 1:8 and 12 through 15 are all electro-fishing details
      # gear_data_notes 10: depth
        
      #as far as I can tell, they'd often deploy the same gear on a single day in a given survey. Those multiple instances of same gear seem to be the way that sample_id.1 arises. 
      wi_inland_effort_19Mar2021[  , .N  , .(sample_id.1)] # so this is our key to the fish dat, I think. 
        
        
        
```

simplify gear types and move notes over to effort columns
```{r}

# Work on making an "effort" and "effort units" column
gear_table <- wi_inland_effort_19Mar2021[ ,.N , sampling_method ]

gear_table[str_detect(sampling_method, "shock") ,simple_gear:= "electrofishing",] 
gear_table[str_detect(sampling_method, "net"), simple_gear:= "netting"]
gear_table[str_detect(sampling_method, "hook"), simple_gear:= "hook and line"]
gear_table[str_detect(sampling_method, "seine"), simple_gear:= "seine"]
gear_table[str_detect(sampling_method, "weir"), simple_gear:= "weir"]
gear_table[str_detect(sampling_method, "trap"), simple_gear:= "trapping"]
gear_table[str_detect(sampling_method, "trawl"), simple_gear:= "trawling"]
gear_table[str_detect(sampling_method, "cage"), simple_gear:= "trapping"]
gear_table[sampling_method=="unknown", simple_gear:= "unknown"]
gear_table[sampling_method=="poison", simple_gear:= "other"]
gear_table[sampling_method=="setline", simple_gear:= "other"]
gear_table[sampling_method=="limbline", simple_gear:= "other"]
gear_table[sampling_method=="visual_observe", simple_gear:= "other"]
gear_table[sampling_method=="multiple_gear_types", simple_gear:= "other"]
gear_table[sampling_method=="bankpole", simple_gear:= "other"]
gear_table[sampling_method=="spearing", simple_gear:= "other"]
gear_table[sampling_method=="scuba_diving", simple_gear:= "other"]
gear_table[sampling_method=="grid", simple_gear:= "other"][]

gear_table[is.na(simple_gear), .N, ]
# all gears have been assigned a "simple gear"

#now add effort and effort units columns
#gear_table[simple_gear == "electrofishing", ':='( effort_col ="distance", effort_units_col = "distance_units")]
#gear_table[simple_gear == "netting", ':='( effort_col ="gear_data_notes.9", effort_units_col = "net_nights")][]


#join gear table back to original data
wi_inland_effort_19Mar2021[gear_table, on = "sampling_method", simple_gear:=simple_gear]
wi_inland_effort_19Mar2021[sampling_method == "fyke_net", , ]
wi_inland_effort_19Mar2021[simple_gear == "electrofishing", ':='( effort = as.character(distance), effort_units = distance_units)]
wi_inland_effort_19Mar2021[simple_gear == "netting", ':='( effort =gear_data_notes.9, effort_units = "net_nights")][]

wi_inland_effort_19Mar2021[ simple_gear == 'netting', .(effort, effort_units) , ]
```

## Prep effort file ## 

Prep WI effort file
```{r}

### doing this with dplyr functions for now, can update to data.table later
    ### how do we want to name the effort columns so they match format from other files/states should we have sample.time 1 and 2 for minutes EF and hours nets are in or should we have total.effort.1 be distance and number of nets and total.effort.2 be minutes EF and hours nets are in..? both are important. Just need a naming scheme

# used code chunk below to check where effort lived for these gears
#wi_gear_eff_check <- wi_inland_effort_19Mar2021 %>%
#  select(gear_data_notes.11, sample_time_notes.1, sample_time_notes.3, gear_data_notes.9, sampling_method)%>%
#  filter(sampling_method %in% c("seine"))


# create effort column based upon which gear was used while retaining all original columns, not perfect, but pretty complete

    ### NOTE we should try to change the dplyr code below to data.table, maybe try "fcase" https://stackoverflow.com/questions/53031140/data-table-alternative-for-dplyr-case-when


wi_inland_effort_19Mar2021 <- wi_inland_effort_19Mar2021 %>%
  # left_join(gear_table, by = "sampling_method")%>% #join gear table SKIP HERE, ACCOMPLISHED ABOVE
  relocate(county, lake_name.1, lake_id, year, survey_id, sample_id.1, sampling_method, simple_gear, date.1, distance, distance_units, sample_time_notes.1, gear_data_notes.9, sample_time_notes.3)%>% #take these columns and put them in front
  mutate(sample_time_min = str_sub(sample_time_notes.1, 22))%>% #keep only the number of minutes
  mutate(hours_set_net = str_sub(sample_time_notes.3, 11)) %>% #keep only the number of hours nets are in
  mutate(number_of_nets = str_sub(gear_data_notes.9, 16))%>% #keep just number of nets
  mutate(distance = as.character(distance))%>% #make this a character so it can be used with other gear types
  # rename(simple_gear = simple_gear.x)%>%
  mutate(total.effort.1 = case_when(simple_gear == "electrofishing" ~ sample_time_min, #create total effort 1
                                    simple_gear == "netting" ~ hours_set_net,
                                    simple_gear == "hook and line" ~ sample_time_min,
                                    simple_gear == "seine" ~ sample_time_min,
                                    simple_gear == "trapping" ~ hours_set_net,
                                    simple_gear == "trawling" ~ sample_time_min,
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ sample_time_min,
                                    sampling_method == "scuba_diving" ~ sample_time_min,
                                    sampling_method == "spearing" ~ hours_set_net,
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ sample_time_min,
                                    sampling_method == "dip_net" ~ sample_time_min,
                                    sampling_method == "setline" ~ sample_time_min,
                                    simple_gear == "seine" ~ hours_set_net))%>%
  mutate(total.effort.2 = case_when(simple_gear == "electrofishing" ~ distance, #create total effort 2 if two relevant efforts
                                    simple_gear == "netting" ~ number_of_nets,
                                    simple_gear == "trapping" ~ number_of_nets,
                                    simple_gear == "seine" ~ number_of_nets))%>%
  mutate(total.effort.1.units = case_when(simple_gear == "electrofishing" ~ "minutes", #assign units to efforts in effort 1
                                    simple_gear == "netting" ~ "hours",
                                    simple_gear == "hook and line" ~ "minutes",
                                    simple_gear == "seine" ~ "minutes",
                                    simple_gear == "trapping" ~ "hours",
                                    simple_gear == "trawling" ~ "minutes",
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ "minutes",
                                    sampling_method == "scuba_diving" ~ "minutes",
                                    sampling_method == "spearing" ~ "hours",
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ "minutes",
                                    sampling_method == "dip_net" ~ "minutes",
                                    sampling_method == "setline" ~ "minutes"))%>%
  mutate(total.effort.2.units = case_when(simple_gear == "electrofishing" ~ "miles", #assign units to efforts in effort 2
                                    simple_gear == "netting" ~ "number_of_nets",
                                    simple_gear == "trapping" ~ "number_of_traps",
                                    simple_gear == "seine" ~ "number_of_nets"))%>%
  mutate(total.effort.1 = na_if(total.effort.1, "NA"))%>% #some of the NAs from the gear_data_notes:NA aren't true NAs, change to true NA
  mutate(total.effort.2 = na_if(total.effort.2, "NA"))%>% #make character NA into true NA
  mutate(total.effort.1.units = ifelse(is.na(total.effort.1), NA, total.effort.1.units))%>% #make character NA into true NA
  mutate(total.effort.2.units = ifelse(is.na(total.effort.2), NA, total.effort.2.units)) #make character NA into true NA
  
#saveRDS(wi_inland_effort, file = "Data_and_Scripts\\Data\\output\\wi_inland_effort.rds")

# wi_effort_subset <- wi_inland_effort %>% 
#   select(county, lake_name.1, lake_id, year, survey_id, sampling_method, date.1, total.effort.1, total.effort.1.units, total.effort.2, total.effort.2.units)#subset these columns to export for later, my r is having a hard time with it
#export as a csv in case r crashes
#write_csv(wi_effort_subset, "wi_inland_effort_gear_table_10JUL2023.csv")       
  
```

Winnebago Trawl Data
- Find a unique key
- Determine effort because it is not listed in its own column
- Determine catch because it is not listed in its own column
```{r}
# date format is "POSIXct" and it won't subset properly, so first change to IDate
wi_winnebago_cpue_23Apr2021[ , date.1 := as.IDate(date.1),]

#subset by date, see if multiple trawls are done per day per site
  # are the species aggregated? Or listed once per site?
wi_winnebago_cpue_23Apr2021[ date.1 == "1986-06-11", .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1) ]
    # appears that there is one trawl per site (using all 4 IDs), species are listed once per site, so CPUE is total catch


# see if this holds true to the whole dataset
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1) ]

# Are there any instances where N > 1
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1) ] [N>1, , ]
    # YES, three instances where N > 1, what else can we add to get a unique key?

#Try adding mesh size (now named "gear_data_notes.1")
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1) ] [N>1, , ]
    # that worked! THIS IS OUR UNIQUE KEY

#check that we have the same number of rows that we started with
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1) ] [, , ]
      # yes we do

# are the units always "catch_per_5_min_trawl" ?
wi_winnebago_cpue_23Apr2021[ ,unique(cpue_units) , ]
    # yes! So effort is constant, always 5 minutes per trawl

# how often are notes included in the data? are they important?
wi_winnebago_cpue_23Apr2021[ ,.N, gear_data_notes.1 ]
    # hardly ever, mostly NA or 0. It is specified 4 times as an actual mesh size. 
```

Format wi_winnebago_cpue_23Apr2021 from just cpue file to a file with catch and effort listed
```{r}
# rename "cpue" column to 'total_count' to match format of other files
    # get all column names from this DT, select only the column named "cpue", rename it "total_count"

    # *note from "lake_winnebago_metadata_readme" : "-since the trawls are 5 minutes each the count values from winnebago_trawl_data.csv are simply summed to compute the cpe"
colnames(wi_winnebago_cpue_23Apr2021)[colnames(wi_winnebago_cpue_23Apr2021)=="cpue"] <- "total_count"


#add a column for effort
wi_winnebago_cpue_23Apr2021[ ,total_effort_1.1 := "5 minute trawl", ]

### would it be helpful to have it be # of fish per minute of trawl? Probably not because the trawls are always the same as is idk it's confusing in its current format
```

count up fish caught in each trawl in fish observation file and compare to fish in caught in cpue file
```{r}

wi_inland_fishobservations_19Mar2021[ , .N ,   ] 

winnebago_calc_cpue <- wi_winnebago_fishobservations_23April2021 %>%
  group_by(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1)%>%
  summarise(Total_Catch = sum(total_count)) #get 49,293 unique surveys as opposed to cpue file of 48,212 surveys

#compare our calc cpue to provided cpue file

winnebago_cpue_comp <- winnebago_calc_cpue %>%
  full_join(wi_winnebago_cpue_23Apr2021[ , date.1 := as.POSIXct(date.1) ,], by = c("site_id.1", "site_id.2", "site_id.3", "site_id.4", "species.1", "date.1", "gear_data_notes.1"))%>%
  mutate(CPUE_Mismatch = ifelse(Total_Catch != total_count, paste("no_match"), paste("match")))

 # no cases where our calculated CPUE doesn't match provided CPUE %>% filter(CPUE_Mismatch == "no_match")
winnebago_cpue_comp%>%
  group_by(CPUE_Mismatch)%>%
  summarise(n())
 # 49,293 unique surveys as opposed to cpue file of 48,212 surveys, so we expect some NA values.
    49293-48212

#there is no information that we need found in the `wi_winnebago_cpue_23Apr2021` file! 
    
    rm(wi_winnebago_cpue_23Apr2021, winnebago_calc_cpue, winnebago_cpue_comp)
```

Finalize Winnebago file so individual fish observations have an effort and effort units column (should be total.effort.1 and total.effort.1.units)
```{r}
wi_winnebago_fishobservations_23April2021  <- wi_winnebago_fishobservations_23April2021 %>%
  mutate(total.effort.1 = "1")%>%
  mutate(total.effort.1.units = "5 minute trawl")%>%
  relocate(year, date.1, lake_name.1, lake_id, site_id.1, site_id.2, site_id.3, site_id.4, gear_data_notes.1, sampling_method, species.1, total_count, length.1, young_of_year, total.effort.1, total.effort.1.units, jan2023_inventoried, file_number, file_status, state, source_contact, date_recieved, source_agency, file_path, new_file_name, file_type, data_type, targeted_or_standard, individual_count, original_file_name.1, unique_row_key.1) %>% #re-order columns
uncount( weights = total_count, .remove = T, .id = "ident_uncount")






#saveRDS(wi_winnebago_fishobservations_23April2021 , file = "Data_and_Scripts\\Data\\output\\wi_winnebago_indiv_fish_w_effort.rds")
```
Winnebago is DONE

Investigate inland_fishobservations file
```{r}
wi_inland_fishobservations_19Mar2021[, .N, .(noage = is.na(age))] #no fish in this file have ages... 

wi_inland_fishobservations_19Mar2021[, .N , .(nolength = is.na(length.1))] #7 million have lengths

wi_inland_fishobservations_19Mar2021[, .N, species.1] #21 species/hybrids
```

are the aged fish also in the wi_inland_fishobservations_19Mar2021 file? (MOVED TO ITS OWN SCRIPT)
```{r}
        
#This is an issue: 

# 
#         # fish_ob_test <- wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", .N ,][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),]
#         # # 650 walleye in a fyke net in this survey
#         # 
#         # 
#         # len_age_test <- wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)]
#         # # 1,137 walleye in fyke net in the same survey, but these fish have no ages, all NA..?
#         # 
#         #   ### in the example above, there are more fish in the length age file than the fish ob file... 
#         # 
#         # fish_ob_plot <- ggplot(data = fish_ob_test, aes(x = length.1))+geom_histogram(binwidth = .5)
#         # len_age_plot <- ggplot(data = len_age_test, aes(x = length.1))+geom_histogram(binwidth = .5)
#         # 
#         # library(cowplot)
#         # compare_plot <- plot_grid(fish_ob_plot, len_age_plot, labels = c("fish observations", "length age")) #same distribution of lengths
#         # 
#         # len_age_test[fish_ob_test, on = .(survey_id, sampling_method, species.1, lake_id, length.1, date.1),nomatch = NULL]
#         # 
#         # matches <- fish_ob_test[ , date.1 := as.POSIXct(date.1) ,] %>%
#         #   inner_join(len_age_test, by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1"))
#         # 
#         # 
#         # data_common1 <- generics::intersect(len_age_test, fish_ob_test)  # Apply intersect function
#         # data_common1 #384 have same survey_id, sampling_method, species, lake id, length and date
# 
# # review the data from that survey (from each source):
# wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", , ][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),][order(length.1)][ ,.N , length.1]
#   wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", , ][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),][order(length.1)]
# 
# wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)][order(length.1)][ ,.N , length.1]
#   wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)][order(length.1)]
# 
#   wi_inland_lenage_19Mar2021[ , date.1 := as.IDate(date.1) , ]
#   
# crosscheck <- merge(
#   wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
#   wi_inland_lenage_19Mar2021[ , .("laaN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
#   by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1")
#   )
# 
# plot(laaN~obsN, data = crosscheck[!is.na(obsN)])
# abline(0,1)
# 
# crosscheck[laaN > obsN] #10k cases (N of lengthXspeciesXgearXsurvey) with more obs in laa data than in the ind fish dataset
# 
# 
# #there are fish with backcalcualted ages (not what we want)
# wi_inland_lenage_19Mar2021[,.N ,(backcalculated_age)] #yes, dp, fl
# 
# #how many ages are NAs?
# wi_inland_lenage_19Mar2021[, .N,is.na(age)] #443,811 fish have ages and 239,785 fish do not have ages (35% of ages are NA)
# 
# # eliminate instances where 1) age is NA 2) age was backcalculated in length age file and 3) summarize by species in survey gear (no lengths) and try a similar test as above
# 
# crosscheck <- merge(
#   wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, sampling_method, species.1, lake_id, date.1) ],
#   wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laaN" = .N), .(survey_id, sampling_method, species.1, lake_id, date.1) ],
#   by = c("survey_id", "sampling_method", "species.1", "lake_id", "date.1"), all = T
#   )
# 
# ggplot(crosscheck, aes(laaN, obsN))+
#   geom_point()+
#   geom_abline(slope = 1, intercept = 0)
# 
# crosscheck[ , laa_subset_prop := laaN/obsN , ]
# 
# ggplot(crosscheck, aes(laa_subset_prop))+
#   geom_histogram()
# 
# crosscheck[ , summary(laa_subset_prop)]
# 
# crosscheck[laaN > obsN] #eliminating the NA ages and backcalculated ages still leaves ~ 50% of the laaN>obsN data 
# 
# 
# Qsurveys <- crosscheck[crosscheck[laaN>obsN, .N, .(survey_id, sampling_method)][ , N := NULL] , , ]
# 
# Qsurveys[ , flagged_laa_obs_Qs := laaN>obsN   ,]
# 
# 
# a <- wi_inland_fishobservations_19Mar2021[survey_id == 651 & species.1 == "yellow_perch"]
# 
# b <- wi_inland_lenage_19Mar2021[survey_id == 651 & species.1 == "yellow_perch"]
# 
# 
# 
# crosscheck <- merge(
#   wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, species.1, lake_id) ],
#   wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laaN" = .N), .(survey_id, species.1, lake_id) ],
#   by = c("survey_id", "species.1", "lake_id"), all = T
#   )
# 
# Qsurveys <- crosscheck[crosscheck[laaN>obsN, .N, .(survey_id)][ , N := NULL] , , ]
# 
# 
# 
# 
# rm(crosscheck)
# 
# wi_inland_fishobservations_19Mar2021[ ]
# colnames(wi_inland_fishobservations_19Mar2021)







```

Does the CPUE file tell us which is correct?
```{r}
#sampling method is simplified.
wi_inland_cpue_19Mar2021[ , unique(sampling_method)]
wi_inland_fishobservations_19Mar2021[ , unique(sampling_method)  , ]
wi_inland_lenage_19Mar2021[ ,unique(sampling_method)  ,]

wi_inland_cpue_19Mar2021[ , .N ,.(survey_id, sampling_method, species.1, lake_id, total_count) ] #this line shows that I have defined a unique key (length = length of full data; no N>1)


#Aggregate these three to a comparable level
wi_inland_cpue_19Mar2021[ , .("cpue_n_gears" = .N, "cpue_Nfish" = sum(total_count)) ,.(survey_id, species.1, lake_id) ]
wi_inland_fishobservations_19Mar2021[ , .("obs_n_gears" = length(unique(sampling_method)) , "obs_Nfish" = .N), .(survey_id, species.1, lake_id) ]
wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laa_n_gears" = length(unique(sampling_method)), "laa_Nfish" = .N), .(survey_id, species.1, lake_id) ]


#this crosscheck has a resolution 1 lower than above because we haven't got full gear types in the cpue files
crosscheck <- merge(
  wi_inland_fishobservations_19Mar2021[ , .("obs_n_gears" = length(unique(sampling_method)) , "obs_Nfish" = .N), .(survey_id, species.1, lake_id) ],
  wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laa_n_gears" = length(unique(sampling_method)), "laa_Nfish" = .N), .(survey_id, species.1, lake_id) ],
  by = c("survey_id","species.1", "lake_id"), all = T
  )

crosscheck <- merge(crosscheck,
wi_inland_cpue_19Mar2021[ , .("cpue_n_gears" = .N, "cpue_Nfish" = sum(total_count)) ,.(survey_id, species.1, lake_id) ],
by = c("survey_id", "species.1", "lake_id"), all = T
)

crosscheck[ , cpue_obs_match := cpue_Nfish == obs_Nfish , ]
crosscheck[ , cpue_laa_match := cpue_Nfish == laa_Nfish , ]
crosscheck[ , laa_exceeds_obs := laa_Nfish>obs_Nfish ]

crosscheck[ , .N , .(cpue_obs_match)]
crosscheck[ , .N , .(cpue_obs_match, cpue_laa_match, laa_exceeds_obs)][order(cpue_obs_match, laa_exceeds_obs)]

#summarize these: 
crosscheck[ , .N , .(cpue_obs_match, cpue_laa_match, laa_exceeds_obs)][order(cpue_obs_match, laa_exceeds_obs)][ , sum(N), cpue_obs_match]
#this says that 3404/of 60027 (5.7%) surveys with both CPUE and fish obs have a mismatch in the catch between files
#the NAs are largely not of concern to me, because they are mostly from 0 speciesXsurvey obs:
crosscheck[ , .N , .(cpue_obs_match, cpue_Nfish == 0)]
#for at least one other case, a stream shocker survey is in the indiv fish obs file but not in the CPUE file. NO idea why.

crosscheck[is.na(cpue_obs_match) & is.na(cpue_Nfish) , ,]
crosscheck[survey_id == 515094436]
wi_inland_fishobservations_19Mar2021[survey_id==515094436]


# add crosscheck flag into the data:
wi_inland_fishobservations_19Mar2021[crosscheck, on = .(species.1, survey_id), FLAGGED_laaN_exceeds_obsN := laa_exceeds_obs ]

wi_inland_fishobservations_19Mar2021[ , .N , FLAGGED_laaN_exceeds_obsN ]


# fwrite(crosscheck, file = "Data_and_Scripts/Data/output/crosscheck_cpue_fishobs_lengthage.csv")
rm(crosscheck)

```


Join wi_inland_fishobservations to the wi_inland_effort
- note, unique key is: .(lake_id, date.1, sampling_method, and sample_id.1) (year can be used too)
```{r}
#change date to IDate
wi_inland_effort_19Mar2021[ , date.1 := as.IDate(date.1,format = "%m/%d/%Y"),]

WI_indiv_fish_w_effort <- merge(wi_inland_fishobservations_19Mar2021, wi_inland_effort_19Mar2021, by = c("lake_id", "date.1", "sampling_method", "sample_id.1"), suffixes = c("_indivfish", "_effort"), all = T)

#saveRDS(WI_indiv_fish_w_effort, file = "Data_and_Scripts\\Data\\output\\wi_indiv_fish_w_effort_no_age.rds")

WI_indiv_fish_w_effort[, total_count:= 1, ]

rm(wi_inland_cpue_19Mar2021, wi_inland_effort_19Mar2021, wi_inland_fishobservations_19Mar2021)


#clean up this data product:

colnames(WI_indiv_fish_w_effort)

#county
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "county")]
WI_indiv_fish_w_effort[ county_indivfish != county_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(countyindvNA = is.na(county_indivfish), countyeffNA = is.na(county_effort)) ] 
WI_indiv_fish_w_effort[is.na(county_effort),  county_effort := county_indivfish ,  ]
WI_indiv_fish_w_effort[ , county_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "county_effort", "county")

#lake_name
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "lake_name")]
WI_indiv_fish_w_effort[ lake_name.1_indivfish != lake_name.1_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(lake_name.1_indivfish), effNA = is.na(lake_name.1_effort)) ] 
WI_indiv_fish_w_effort[is.na(lake_name.1_effort),  lake_name.1_effort := lake_name.1_indivfish ,  ]
WI_indiv_fish_w_effort[ , lake_name.1_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "lake_name.1_effort", "lake_name.1")

#year
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "year")] #what's here for year data?
#move indiv fish years to effort
WI_indiv_fish_w_effort[ year_indivfish != year_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(year_indivfish), effNA = is.na(year_effort) ) ] 
WI_indiv_fish_w_effort[is.na(year_effort),  year_effort := year_indivfish ,  ]
WI_indiv_fish_w_effort[ , year_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "year_effort", "year")

#survey_id
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "survey_id")] #what's here for this var name?
#consolidate if possible
WI_indiv_fish_w_effort[ survey_id_indivfish != survey_id_effort , .N ,  ] #any disagreememnt among non-NA fields
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(survey_id_indivfish), effNA = is.na(survey_id_effort) ) ] # whats the NA coverage look like?
WI_indiv_fish_w_effort[is.na(survey_id_effort),  survey_id_effort := survey_id_indivfish ,  ]
WI_indiv_fish_w_effort[ , survey_id_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "survey_id_effort", "survey_id")

#survey_type.1
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "survey_type.1")] #what's here for this var name?
#consolidate if possible
WI_indiv_fish_w_effort[ survey_type.1_indivfish != survey_type.1_effort , .N ,  ] #any disagreememnt among non-NA fields
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(survey_type.1_indivfish), effNA = is.na(survey_type.1_effort) ) ] # whats the NA coverage look like?
#mostly disagreement, need to retain both. 

#state
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "state")] #what's here for this var name?
#consolidate if possible
WI_indiv_fish_w_effort[ state_indivfish != state_effort , .N ,  ] #any disagreememnt among non-NA fields
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(state_indivfish), effNA = is.na(state_effort) ) ] # whats the NA coverage look like?
WI_indiv_fish_w_effort[is.na(state_effort),  state_effort := state_indivfish ,  ]
WI_indiv_fish_w_effort[ , state_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "state_effort", "state")

#total_count
WI_indiv_fish_w_effort[ , unique(total_count) , ]

#drop age data
WI_indiv_fish_w_effort[ , unique(age)]
WI_indiv_fish_w_effort[ , unique(aging_structure),]
WI_indiv_fish_w_effort[ , `:=` (age = NULL, aging_structure = NULL) ,]





not_garbage <- c( 
  "lake_id",                        "date.1",                         "sampling_method",                "sample_id.1",                   
  "species.1",                      "length.1",                       "state",
  "length_unit.1",                  "weight.1" ,                      "weight_unit.1",                  "sex",                            
  "young_of_year",                  "survey_type.1_indivfish",        "survey_type.2_indivfish",        "survey_type.1_effort",
  "survey_type.2_effort",           "county",                         "lake_name.1",                   
  "year",                           "survey_id",                      "simple_gear",                    "distance",                      
  "effort",                         "effort_units",                  
  "total.effort.1",                 "total.effort.2",                 "total.effort.1.units",           "total.effort.2.units",           "total_count"  
)


setcolorder(WI_indiv_fish_w_effort, not_garbage)

```

*** things we may want to change about the merge above
- do we want to retain duplicate columns with suffixes? Or have them combined into a single column?
 This is not as easy as one or the other-- where theres data in both sets for a given field, we have to keep both (see survey_type.1, above). I think this generally suggests a need to visit each column individually. 

- do we want total catch at all?
  I'd argue that we don't need to. we examine that quality of that data in the crosscheck section, above. 



Bind winnebago and inland data together
```{r}
#prep for merge

#nix all unnneeded dat from mem

rm(wi_inland_lenage_19Mar2021, cde, gear_table, names, unusedbits)


#ensure all formats are DT. 
str(WI_indiv_fish_w_effort)
str(wi_winnebago_fishobservations_23April2021)



#fix date
wi_winnebago_fishobservations_23April2021 [ , date.1 := as.IDate(date.1,format = "%Y/%m/%d"),]


WI_indiv_fish_w_effort <- rbindlist(list(WI_indiv_fish_w_effort, wi_winnebago_fishobservations_23April2021 ),
                               fill = TRUE,
                               use.names = TRUE)

rm(wi_winnebago_fishobservations_23April2021 )

#clean up this data product:

colnames(WI_indiv_fish_w_effort)

# #county
# colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "county")]
# WI_indiv_fish_w_effort[ county_indivfish != county_effort , .N ,  ] 
# WI_indiv_fish_w_effort[  , .N , .(countyindvNA = is.na(county_indivfish), countyeffNA = is.na(county_effort)) ] 
# WI_indiv_fish_w_effort[is.na(county_effort),  county_effort := county_indivfish ,  ]
# WI_indiv_fish_w_effort[ , county_indivfish := NULL , ]
# setnames(WI_indiv_fish_w_effort, "county_effort", "county")
# 
# #lake_name
# colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "lake_name")]
# WI_indiv_fish_w_effort[ lake_name.1_indivfish != lake_name.1_effort , .N ,  ] 
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(lake_name.1_indivfish), effNA = is.na(lake_name.1_effort)) ] 
# WI_indiv_fish_w_effort[is.na(lake_name.1_effort),  lake_name.1_effort := lake_name.1_indivfish ,  ]
# WI_indiv_fish_w_effort[ , lake_name.1_indivfish := NULL , ]
# #move effort lake_name to reg lake_name column
# WI_indiv_fish_w_effort[ lake_name.1!= lake_name.1_effort , .N ,  ] 
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(lake_name.1), effNA = is.na(lake_name.1_effort) ) ] 
# WI_indiv_fish_w_effort[is.na(lake_name.1),  lake_name.1 := lake_name.1_effort ,  ]
# WI_indiv_fish_w_effort[ , lake_name.1_effort := NULL , ]
# 
# #year
# colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "year")] #what's here for year data?
# #move indiv fish years to effort
# WI_indiv_fish_w_effort[ year_indivfish != year_effort , .N ,  ] 
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(year_indivfish), effNA = is.na(year_effort) ) ] 
# WI_indiv_fish_w_effort[is.na(year_effort),  year_effort := year_indivfish ,  ]
# WI_indiv_fish_w_effort[ , year_indivfish := NULL , ]
# #move effort years to reg years column
# WI_indiv_fish_w_effort[ year!= year_effort , .N ,  ] 
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(year), effNA = is.na(year_effort) ) ] 
# WI_indiv_fish_w_effort[is.na(year),  year := year_effort ,  ]
# WI_indiv_fish_w_effort[ , year_effort := NULL , ]
# 
# #survey_id
# colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "survey_id")] #what's here for this var name?
# #consolidate if possible
# WI_indiv_fish_w_effort[ survey_id_indivfish != survey_id_effort , .N ,  ] #any disagreememnt among non-NA fields
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(survey_id_indivfish), effNA = is.na(survey_id_effort) ) ] # whats the NA coverage look like?
# WI_indiv_fish_w_effort[is.na(survey_id_effort),  survey_id_effort := survey_id_indivfish ,  ]
# WI_indiv_fish_w_effort[ , survey_id_indivfish := NULL , ]
# setnames(WI_indiv_fish_w_effort, "survey_id_effort", "survey_id")
# 
# #survey_type.1
# colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "survey_type.1")] #what's here for this var name?
# #consolidate if possible
# WI_indiv_fish_w_effort[ survey_type.1_indivfish != survey_type.1_effort , .N ,  ] #any disagreememnt among non-NA fields
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(survey_type.1_indivfish), effNA = is.na(survey_type.1_effort) ) ] # whats the NA coverage look like?
# #mostly disagreement, need to retain both. 
# 
# #state
# colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "state")] #what's here for this var name?
# #consolidate if possible
# WI_indiv_fish_w_effort[ state_indivfish != state_effort , .N ,  ] #any disagreememnt among non-NA fields
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(state_indivfish), effNA = is.na(state_effort) ) ] # whats the NA coverage look like?
# WI_indiv_fish_w_effort[is.na(state_effort),  state_effort := state_indivfish ,  ]
# WI_indiv_fish_w_effort[ , state_indivfish := NULL , ]
# #move effort years to reg years column
# WI_indiv_fish_w_effort[ state!= state_effort , .N ,  ] 
# WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(state), effNA = is.na(state_effort) ) ] 
# WI_indiv_fish_w_effort[is.na(state),  state := state_effort ,  ]
# WI_indiv_fish_w_effort[ , state_effort := NULL , ]
# 
# WI_indiv_fish_w_effort[ , unique(simple_gear) , ]


```


## Export a WI file, Import a WI file, Reformat to Arrow

```{r}
saveRDS(WI_indiv_fish_w_effort, "E:/My Drive/Documents/UMN/Hansen Lab/Rprojects/CASC_Fish_Climate/Data_and_Scripts/Data/output/wi_flat_effort_indivfish_merge.rds")

WI_indiv_fish_w_effort <- readRDS("E:/My Drive/Documents/UMN/Hansen Lab/Rprojects/CASC_Fish_Climate/Data_and_Scripts/Data/output/wi_flat_effort_indivfish_merge.rds")

WI_indiv_fish_w_effort <- as_arrow_table(WI_indiv_fish_w_effort)


#arrow file print:
WI_indiv_fish_w_effort

#now dplyr
glimpse(WI_indiv_fish_w_effort)

#try a piped operation (note the "lazy evaluation" means require collect())
WI_indiv_fish_w_effort %>% 
  group_by(species.1) %>%
  summarise(sum(!is.na(weight.1)))%>%
  collect()%>%
  print(n = 22)



colnames(WI_indiv_fish_w_effort)

WI_indiv_fish_w_effort %>%

  summarize(n())
glimpse()

```


#export as parquet file
```{r}

write_dataset(dataset = WI_indiv_fish_w_effort, path = "Data_and_Scripts/Data/output/wi_file_arrow")

wi_data <- open_dataset("Data_and_Scripts/Data/output/wi_file_arrow")

glimpse(wi_data)

```


# Priority column tidying 
```{r}

#print all column names
wi_data %>%
  names() %>%
  sort()


#species column
#cols containing "species" (skipping pipe to names includes a format report from arrow)
wi_data %>% 
  select(contains("species"))
  # %>%
  # names()
#view unique names of species:
wi_data %>% 
  select(species.1) %>% 
  unique() %>%
  arrange(species.1) %>%
  collect() %>%
  print(n = nrow(.))

wi_data %>% 
  group_by(species.1) %>% 
  summarise( n = n()) %>% 
  arrange( n) %>% 
  collect() %>% 
  print(n = nrow(.))

wi_data %>% 
  filter(is.na(species.1)) %>%
  select(survey_id, sampling_method, site_id.1, site_id.2, site_id.3, site_id.4, date.1) %>% 
  collect() %>% 
  {species_NA_surveys <<- . }


wi_data %>% 
  inner_join(species_NA_surveys) %>% 
  compute()


#these look fine to me. They comply with the Data Agg Doc specs here: https://docs.google.com/document/d/1Ax_4vmsIqDuWU8wtxBRXv73mbLB_TjT4B2gG6Yp_tkQ/edit?pli=1#heading=h.f6zxnh5xaf40







#location columns
#lake_id & lake_name
wi_data %>%
  select(contains("lake"))%>%
  unique()%>%
  collect()

#all lake loc data:
#here I review glimpse(wi_data) and call only the location-ey fields
wi_data %>% 
  select(lake_id, lake_name.1, state, county, location_notes.1, location_notes.2, location_notes.3, site_id.1, site_id.2, site_id.3, site_id.4 )%>%
  unique() %>%
  compute()

# I suspect the site IDs are winnebago specific
wi_data %>% 
  filter( !is.na(site_id.1)) %>% 
  select(lake_name.1) %>% 
  unique() %>% 
  collect()
# it is. drop that from the location data, above

#here I review glimpse(wi_data) and call only the location-ey fields
wi_data %>% 
  select(lake_id, lake_name.1, state, county, location_notes.1, location_notes.2, location_notes.3 )%>%
  unique() %>%
  compute()

#now check these fields one at a time (lake_name and id are done)
wi_data %>% 
  select(state) %>% 
  unique() %>%
  collect()
#view unique names of counties:
wi_data %>% 
  group_by(county) %>% 
  summarize( n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))

# NA counties are a diverse set of waterbodies:
wi_data %>% 
  filter( !is.na(county)) %>% 
  select(lake_name.1) %>% 
  unique() %>% 
  collect() %>% 
  print( n = 100)






#now review the date columns
#fields with "date"
wi_data %>%
  select(contains("date"))
#date.1 is the only useful column here:

#any NAs in date? NO!
wi_data %>%
  filter(is.na(date.1))%>%
  compute()

wi_data %>%
  select(date.1)%>%
  compute() 

wi_data %>%
  select(date.1)%>%
  collect() %>% 
  summary() 

# seems unlikely that there are fish data from 1899...
wi_data %>%
  filter(date.1 < "1940-1-1")%>%
  select(date.1) %>% 
  collect()

wi_data %>% 
  filter(lake_id == 99999) %>% 
  select(lake_name.1) %>% 
  unique() %>% 
  collect()

#definitely odd, but I don't know that we have any way of determining the true date in these. Let's flag those dates as questionable

wi_data %>%
  # filter(date.1 < "1940-1-1") %>% 
  mutate(FLAGGED_date_questionable = date.1 < "1930-1-1") %>% 
  select(FLAGGED_date_questionable ) %>% 
  compute()

#in order to amend the parquet file, I'd need to load it into R, add that column then re-write to disk. 


#gear

wi_data %>% 
  select(sampling_method) %>% 
  unique() %>% 
  compute() %>% 
  collect() %>% 
  print(n = nrow(.))

wi_data %>% 
  group_by(sampling_method) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print( n = nrow(.))  



#target species













#see if this file has my QC flag in it
wi_data %>%
  select(contains("flag"))


````


``` {r}

#explain the no fish caught situation in these data:
#examine the species.1 = NA cases

wi_data %>%
  filter(is.na(species.1))%>%
  select(survey_id, sampling_method, lake_id, lake_name.1, date.1, ident_uncount) %>%
  distinct(survey_id) %>%
  collect() %>%
  { . ->> survey_w_NA_spp}
  







````





















