---
title: "b_WI_Flat_File_Aggregation"
author: "Holly Kundel & Mike Verhoeven"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---



# Outstanding work

DONE  1. Fix data import to squash warnings and add ticker
DONE  2. Button up the column name cleaning section of the file
DONE  2b. consider a reformat to Arrow (sooner) for speed -- currently implemented at end, consider implementing this step earlier. 
DONE  3. Add section for (minimal acceptable) data proofing
DONE  4. Lake winnebago data are not yet "uncount" ed
DUP2  5. Need to tidy up as many colnames as possible at each merge phase to prevent huge buildup of shit at the end (see current section at line 550ish)
DONE  6.Crosscheck to CPUE file provided to us to check calcs/agreement
DONE  6a. Flag abunds affected by this mismatch
DONE  7. Winnebago data included all species, want to constrain to be same as the main WI dataset.
DONE  8. add an effort_ident to each trawl haul from Winnebago-- note the weirdness of this (one lake, many cpues in a single day)
DONE  8a. add effort_ident to each surveyXgear?
DONE  9. Connect ages back to the fish observations (Diagnostics ideas -- check some unpaired age data and see if you can find the obs that should match it)
DONE  10. Flag crazy dates
DONE  11. Add a nothing_caught tag
DONE  12. Add NHDids
DONE  13. cleannames() to colnames
      14. Update the total effort ident grouping to be at the surveyXgearXdate level
      
      

# Preamble

libraries
```{r}
library(arrow)
library(readr)
library(dplyr)
library(stringr)
library(data.table)
library(janitor)
library(tidyr)
library(lubridate)
library(ggplot2)
library(mwlaxeref)

options(scipen = 999)
```


# Load Data

* First run CASC Data Explainer
* note Holly has to change "E" in file paths to "D" 
* This data import block takes about 10 minutes to run
* needs an update to nix warnings (see Github issue on this)
```{r}
#generate a file list to import
files_list <- list.files(path = "E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data", pattern = ".+\\.csv") #grabs only.csv files
#grabs only.csv files
files_list

#object for use in loop (simple length of file list)
n <- length(files_list)

for(i in 1:n) {
  #i = 4
  filei <- word(gsub(".csv","", files_list[i]), start = -1, sep = fixed("/"))
  #this does those two steps in one package
  assign(filei ,
          fread(paste0("E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data/",
                                          files_list[i])))
  
  # if the file is a crosswalk, do not rename anything, just loop to the confirm import line
  if(str_detect(filei, "crosswalk")) {  #confirm import of files:  
    print(paste(filei ,"added to workspace" ))  
    #confirm import of files:  
    print(paste(i ,"files added to workspace" )) ; next}
  
  
  # note we want to review a sorted list of column names to check misspelling etc.
  # we still need to use the columns with names like col_name_length_in, or known_units
  
  
  cde %>% # call data explainer file
    filter(`new_file_name`== filei)%>% #keep only the row relevant to this file
    select_if(~ !any(is.na(.))) %>% 
    transpose(keep.names = "newname") %>% 
    rename("oldname" = V1) %>% 
    assign("names", ., envir = .GlobalEnv)
  
  #see if any column names will not have a match! 
  # IF any pop FALSE, force stop and revist of data explainer ()
  # - e.g., named something "total catch" when actual column name was "total_catch"
  print(
    cbind(colnames(get(filei)),
          colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]
    )
  )
  
    
  # break the loop if the current file has column names not in the data explainer
  # if (all(cbind(colnames(get(filei)),  colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ])[,2]) == FALSE ) break
  if (all(colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]) == FALSE ) break
  
  
  # append old col names into new "notes" columns:
  get(filei)[ , (names[ str_detect(newname, "notes") , oldname   ,  ]) := Map(paste, colnames(.SD), .SD, sep = ':') , .SDcols =  names[ str_detect(newname, "notes") , oldname   ,  ] ]
  
  #now rename that file's colnames
  setnames(get(filei), colnames(get(filei)), names[!str_detect(newname,"unique_row_key")] [match(names(get(filei)),names[!str_detect(newname,"unique_row_key"),oldname]), newname] )
  
  #append all other data from data explainer
  unusedbits <- 
    data.table(
      matrix(
        rep(names[ !newname %in% colnames(get(filei)) , oldname , ],
            each = nrow(get(filei))
        ),
        nrow = nrow(get(filei)),
        dimnames = list(rep(NA,nrow(get(filei))),
                        names[ !newname %in% colnames(get(filei)) , newname , ])
        )
      )
  
  #add all not yet used columns from data explainer:
  get(filei)[ , (names[ !newname %in% colnames(get(filei)) , newname , ]) := unusedbits[] ]

  #confirm import of files:  
  print(paste(filei ,"added to workspace" ))  
  #confirm import of files:  
  print(paste(i ,"files added to workspace" )) 

  
} 

  #confirm import of files:  
  print(paste(i ,"files added to workspace" ))
  #confirm import of files:  
  print(paste(n-i ,"remaining to be added" )) 

```

# Identify Which data types are in each file
[1] "wi_inland_cpue_19Mar2021.csv"                  ~ CPUE (Effort and Catch)                 
[2] "wi_inland_effort_19Mar2021.csv"                ~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)          
[3] "wi_inland_fishobservations_19Mar2021.csv"      ~ Individual Fish    
[4] "wi_inland_lenage_19Mar2021.csv"                ~ Individual Fish             
[5] "wi_winnebago_cpue_23Apr2021.csv"               ~ CPUE (just has CPUE and units for CPUE)       LINE 338 - LINE 356 shows that this file is redundant and unneeded.       
[6] "wi_winnebago_fishobservations_23April2021.csv" ~ Individual Fish NO THIS IS NOT!!!!!!!!!


## Explore Effort Data

Inland effort data exploration ([2] "wi_inland_effort_19Mar2021.csv"~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)   )
```{r}
# Only one "True Effort" file (each row is a gear in a survey): 'wi_inland_effort_19Mar2021'

# Rest of the files with Effort also have catch (species in a gear with a survey)

# CPUE/Effort Files with Catch: "wi_inland_cpue_19Mar2021" 

# wi_winnebago_cpue_23Apr2021.csv ~ only has CPUE and CPUE units. No catch or effort
    # effort for all winnebago surveys is "5 min trawl"
    


#investigate the one true effort file we have

# gears present
wi_inland_effort_19Mar2021[ ,.N , sampling_method ]
  # 53 unique gears: electrofishing, nets, hook and line, traps, trawls, etc.

wi_inland_effort_19Mar2021[sampling_method=="seine" , ,  ][gear_data_notes.9 == "number.of.nets:NA"]

# where do actual efforts live for each type of gear
wi_inland_effort_19Mar2021[ ,.N , .(sampling_method, distance, sample_time_notes.1, gear_data_notes.9) ]
  # it appears any kind of shocking effort is in "sample_time_notes.1 and "distance"
  # net effort is in "gear_data_notes.9"

#whats this line do? 
# wi_inland_effort_19Mar2021[ ,.(sampling_method, distance, gear_data_notes.1, gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, gear_data_notes.5, gear_data_notes.6, gear_data_notes.7, gear_data_notes.8, gear_data_notes.9, gear_data_notes.10, gear_data_notes.11, gear_data_notes.12, gear_data_notes.13, sample_time_notes.1, sample_time_notes.2) , sampling_method]

#is survey_id unique to each survey?
wi_inland_effort_19Mar2021[ ,  , survey_id] # Holly E said to be cautious about survey ID #THIS LINE JUST PRINTS THE ENTIRE DATASET
  wi_inland_effort_19Mar2021[ , .N , survey_id]
    # yes! NO THE SURVEY ID IS NOT A UNIQUE KEY HERE
wi_inland_effort_19Mar2021[ ,  , .(lake_id, date.1, sampling_method)] #THIS LINE JUST PRINTS THE ENTIRE DATASET
  wi_inland_effort_19Mar2021[ , .N  , .(lake_id, date.1, sampling_method)]
  # lake_id, date.1, and sampling_method also work as a key
  #NO THEY DONT

# does "year" work as well as "date.1" ?
wi_inland_effort_19Mar2021[ , , .(lake_id, year, sampling_method)] #THIS LINE JUST PRINTS THE ENTIRE DATASET TRY THESE:
      wi_inland_effort_19Mar2021[ ,.N , .(lake_id, sampling_method)]
      wi_inland_effort_19Mar2021[ , .N , .(lake_id, year, sampling_method)]
  # for the inland data, year works just as well
      #^NOT RIGHT
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, date.1, sampling_method)]
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, year, date.1, sampling_method)] # why does year add identity to these data!?!??!
          wi_inland_effort_19Mar2021[ , unique(date.1) , ]
          wi_inland_effort_19Mar2021[ word(date.1, -1, sep = "/") != year , . (date.1, year) , ] #in the orginal data, date == "sample date", whereas year == "survey year"
          #reviewing a bit of this data suggests that there are surveys that lasted multiple years (like maybe they were mark-recpature or cohort tracking mortality estimating special surveys. Not sure TBH)
        
        
       #NEED TO VERIIFY HERE THAT THE VARIABLE VISIT.FISH.SEQ.NO is a surveyXgearID
        wi_inland_effort_19Mar2021[  , .N  , .(sample_id.1)] # so obviously this is a good key (sample_id.1 matches n obs in file total)
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, survey_id, year, date.1, sampling_method)] #try to understand what makes a row (sample-wise)
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)] [ , hist(N) ,]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)] [ , summary(N) ,]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method,
                                             #gear data adds ident value to the set
                                             distance, sample_time_notes.1, sample_time_notes.2, sample_time_notes.3, 
                                             gear_data_notes.1, 
                                             gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, 
                                             gear_data_notes.5, 
                                             gear_data_notes.6, 
                                             gear_data_notes.7, 
                                             gear_data_notes.8, 
                                             gear_data_notes.9, 
                                             gear_data_notes.10, 
                                             gear_data_notes.11, 
                                             gear_data_notes.12, gear_data_notes.13, gear_data_notes.14, gear_data_notes.15)]
      # IMO this suggests that any effort data loaded into any sort of bigger pipeline ought to REQUIRE an input (allow many?) of total effort. 
      # gear_data_notes 1:8 and 12 through 15 are all electro-fishing details
      # gear_data_notes 10: depth
        
      #as far as I can tell, they'd often deploy the same gear on a single day in a given survey. Those multiple instances of same gear seem to be the way that sample_id.1 arises. 
      wi_inland_effort_19Mar2021[  , .N  , .(sample_id.1)] # so this is our key to the fish dat, I think. 
        
        
        
```

simplify gear types and move notes over to effort columns
```{r}

# Work on making an "effort" and "effort units" column
gear_table <- wi_inland_effort_19Mar2021[ ,.N , sampling_method ]

gear_table[str_detect(sampling_method, "shock") ,simple_gear:= "electrofishing",] 
gear_table[str_detect(sampling_method, "net"), simple_gear:= "netting"]
gear_table[str_detect(sampling_method, "hook"), simple_gear:= "hook and line"]
gear_table[str_detect(sampling_method, "seine"), simple_gear:= "seine"]
gear_table[str_detect(sampling_method, "weir"), simple_gear:= "weir"]
gear_table[str_detect(sampling_method, "trap"), simple_gear:= "trapping"]
gear_table[str_detect(sampling_method, "trawl"), simple_gear:= "trawling"]
gear_table[str_detect(sampling_method, "cage"), simple_gear:= "trapping"]
gear_table[sampling_method=="unknown", simple_gear:= "unknown"]
gear_table[sampling_method=="poison", simple_gear:= "other"]
gear_table[sampling_method=="setline", simple_gear:= "other"]
gear_table[sampling_method=="limbline", simple_gear:= "other"]
gear_table[sampling_method=="visual_observe", simple_gear:= "other"]
gear_table[sampling_method=="multiple_gear_types", simple_gear:= "other"]
gear_table[sampling_method=="bankpole", simple_gear:= "other"]
gear_table[sampling_method=="spearing", simple_gear:= "other"]
gear_table[sampling_method=="scuba_diving", simple_gear:= "other"]
gear_table[sampling_method=="grid", simple_gear:= "other"][]

gear_table[is.na(simple_gear), .N, ]
# all gears have been assigned a "simple gear"

#now add effort and effort units columns
#gear_table[simple_gear == "electrofishing", ':='( effort_col ="distance", effort_units_col = "distance_units")]
#gear_table[simple_gear == "netting", ':='( effort_col ="gear_data_notes.9", effort_units_col = "net_nights")][]


#join gear table back to original data
wi_inland_effort_19Mar2021[gear_table, on = "sampling_method", simple_gear:=simple_gear]
wi_inland_effort_19Mar2021[sampling_method == "fyke_net", , ]
wi_inland_effort_19Mar2021[simple_gear == "electrofishing", ':='( effort = as.character(distance), effort_units = distance_units)]
wi_inland_effort_19Mar2021[simple_gear == "netting", ':='( effort =gear_data_notes.9, effort_units = "net_nights")][]

wi_inland_effort_19Mar2021[ simple_gear == 'netting', .(effort, effort_units) , ]
```

## Prep effort file

Prep WI effort file
```{r}

### doing this with dplyr functions for now, can update to data.table later
    ### how do we want to name the effort columns so they match format from other files/states should we have sample.time 1 and 2 for minutes EF and hours nets are in or should we have total.effort.1 be distance and number of nets and total.effort.2 be minutes EF and hours nets are in..? both are important. Just need a naming scheme

# used code chunk below to check where effort lived for these gears
#wi_gear_eff_check <- wi_inland_effort_19Mar2021 %>%
#  select(gear_data_notes.11, sample_time_notes.1, sample_time_notes.3, gear_data_notes.9, sampling_method)%>%
#  filter(sampling_method %in% c("seine"))


# create effort column based upon which gear was used while retaining all original columns, not perfect, but pretty complete

    ### NOTE we should try to change the dplyr code below to data.table, maybe try "fcase" https://stackoverflow.com/questions/53031140/data-table-alternative-for-dplyr-case-when


wi_inland_effort_19Mar2021 <- wi_inland_effort_19Mar2021 %>%
  # left_join(gear_table, by = "sampling_method")%>% #join gear table SKIP HERE, ACCOMPLISHED ABOVE
  relocate(county, lake_name.1, lake_id, year, survey_id, sample_id.1, sampling_method, simple_gear, date.1, distance, distance_units, sample_time_notes.1, gear_data_notes.9, sample_time_notes.3)%>% #take these columns and put them in front
  mutate(sample_time_min = str_sub(sample_time_notes.1, 22))%>% #keep only the number of minutes
  mutate(hours_set_net = str_sub(sample_time_notes.3, 11)) %>% #keep only the number of hours nets are in
  mutate(number_of_nets = str_sub(gear_data_notes.9, 16))%>% #keep just number of nets
  mutate(distance = as.character(distance))%>% #make this a character so it can be used with other gear types
  # rename(simple_gear = simple_gear.x)%>%
  mutate(total.effort.1 = case_when(simple_gear == "electrofishing" ~ sample_time_min, #create total effort 1
                                    simple_gear == "netting" ~ hours_set_net,
                                    simple_gear == "hook and line" ~ sample_time_min,
                                    simple_gear == "seine" ~ sample_time_min,
                                    simple_gear == "trapping" ~ hours_set_net,
                                    simple_gear == "trawling" ~ sample_time_min,
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ sample_time_min,
                                    sampling_method == "scuba_diving" ~ sample_time_min,
                                    sampling_method == "spearing" ~ hours_set_net,
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ sample_time_min,
                                    sampling_method == "dip_net" ~ sample_time_min,
                                    sampling_method == "setline" ~ sample_time_min,
                                    simple_gear == "seine" ~ hours_set_net))%>%
  mutate(total.effort.2 = case_when(simple_gear == "electrofishing" ~ distance, #create total effort 2 if two relevant efforts
                                    simple_gear == "netting" ~ number_of_nets,
                                    simple_gear == "trapping" ~ number_of_nets,
                                    simple_gear == "seine" ~ number_of_nets))%>%
  mutate(total.effort.1.units = case_when(simple_gear == "electrofishing" ~ "minutes", #assign units to efforts in effort 1
                                    simple_gear == "netting" ~ "hours",
                                    simple_gear == "hook and line" ~ "minutes",
                                    simple_gear == "seine" ~ "minutes",
                                    simple_gear == "trapping" ~ "hours",
                                    simple_gear == "trawling" ~ "minutes",
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ "minutes",
                                    sampling_method == "scuba_diving" ~ "minutes",
                                    sampling_method == "spearing" ~ "hours",
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ "minutes",
                                    sampling_method == "dip_net" ~ "minutes",
                                    sampling_method == "setline" ~ "minutes"))%>%
  mutate(total.effort.2.units = case_when(simple_gear == "electrofishing" ~ "miles", #assign units to efforts in effort 2
                                    simple_gear == "netting" ~ "number_of_nets",
                                    simple_gear == "trapping" ~ "number_of_traps",
                                    simple_gear == "seine" ~ "number_of_nets"))%>%
  mutate(total.effort.1 = na_if(total.effort.1, "NA"))%>% #some of the NAs from the gear_data_notes:NA aren't true NAs, change to true NA
  mutate(total.effort.2 = na_if(total.effort.2, "NA"))%>% #make character NA into true NA
  mutate(total.effort.1.units = ifelse(is.na(total.effort.1), NA, total.effort.1.units))%>% #make character NA into true NA
  mutate(total.effort.2.units = ifelse(is.na(total.effort.2), NA, total.effort.2.units)) #make character NA into true NA
  
#saveRDS(wi_inland_effort, file = "Data_and_Scripts\\Data\\output\\wi_inland_effort.rds")

# wi_effort_subset <- wi_inland_effort %>% 
#   select(county, lake_name.1, lake_id, year, survey_id, sampling_method, date.1, total.effort.1, total.effort.1.units, total.effort.2, total.effort.2.units)#subset these columns to export for later, my r is having a hard time with it
#export as a csv in case r crashes
#write_csv(wi_effort_subset, "wi_inland_effort_gear_table_10JUL2023.csv")       
  
```

## Winnebago Data (Gillnets and Trawls)
- Find a unique key
- Determine effort because it is not listed in its own column
- Determine catch because it is not listed in its own column
```{r}
# date format is "POSIXct" and it won't subset properly, so first change to IDate
wi_winnebago_cpue_23Apr2021[ , date.1 := as.IDate(date.1),]

#these data are not just trawls
wi_winnebago_cpue_23Apr2021[ , .N , .(year(date.1), sampling_method) ]
wi_winnebago_fishobservations_23April2021[ , .N , .(year(date.1), sampling_method) ]


#subset by date, see if multiple trawls are done per day per site
  # are the species aggregated? Or listed once per site?
wi_winnebago_cpue_23Apr2021[ date.1 == "1986-06-11", .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, sampling_method) ]
    # appears that there is one trawl per site (using all 4 IDs), species are listed once per site, so CPUE is total catch


# see if this holds true to the whole dataset
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1) ]

# Are there any instances where N > 1
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1) ] [N>1, , ]
    # YES, three instances where N > 1, what else can we add to get a unique key?

#Try adding mesh size (now named "gear_data_notes.1")
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1) ] [N>1, , ]
    # that worked! THIS IS OUR UNIQUE KEY

#check that we have the same number of rows that we started with
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1) ] [, , ]
      # yes we do

# are the units always "catch_per_5_min_trawl" ?
wi_winnebago_cpue_23Apr2021[ ,unique(cpue_units) , ]
    # yes! So effort is constant, always 5 minutes per trawl

# how often are notes included in the data? are they important?
wi_winnebago_cpue_23Apr2021[ ,.N, gear_data_notes.1 ]
    # hardly ever, mostly NA or 0. It is specified 4 times as an actual mesh size. 
```

Format wi_winnebago_cpue_23Apr2021 from just cpue file to a file with catch and effort listed
```{r}
# rename "cpue" column to 'total_count' to match format of other files
    # get all column names from this DT, select only the column named "cpue", rename it "total_count"

    # *note from "lake_winnebago_metadata_readme" : "-since the trawls are 5 minutes each the count values from winnebago_trawl_data.csv are simply summed to compute the cpe"
colnames(wi_winnebago_cpue_23Apr2021)[colnames(wi_winnebago_cpue_23Apr2021)=="cpue"] <- "total_count"


#add a column for effort
wi_winnebago_cpue_23Apr2021[ ,total_effort_1.1 := "5 minute trawl", ]

### would it be helpful to have it be # of fish per minute of trawl? Probably not because the trawls are always the same as is idk it's confusing in its current format
```

count up fish caught in each trawl in fish observation file and compare to fish in caught in cpue file -->
```{r}

winnebago_calc_cpue <- wi_winnebago_fishobservations_23April2021 %>%
  group_by(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1)%>%
  summarise(Total_Catch = sum(individual_count)) #get 49,293 unique surveys as opposed to cpue file of 48,212 surveys

#compare our calc cpue to provided cpue file

winnebago_cpue_comp <- winnebago_calc_cpue %>%
  full_join(wi_winnebago_cpue_23Apr2021[ , date.1 := as.POSIXct(date.1) ,], by = c("site_id.1", "site_id.2", "site_id.3", "site_id.4", "species.1", "date.1", "gear_data_notes.1"))%>%
  mutate(CPUE_Mismatch = ifelse(Total_Catch != total_count, paste("no_match"), paste("match")))

 # no cases where our calculated CPUE doesn't match provided CPUE %>% filter(CPUE_Mismatch == "no_match")
winnebago_cpue_comp%>%
  group_by(CPUE_Mismatch)%>%
  summarise(n())
 # 49,293 unique surveys as opposed to cpue file of 48,212 surveys, so we expect some NA values.
    49293-48212

#there is no information that we need found in the `wi_winnebago_cpue_23Apr2021` file! 
    
    rm(wi_winnebago_cpue_23Apr2021, winnebago_calc_cpue, winnebago_cpue_comp)
```

Finalize Winnebago file so individual fish observations have an effort and effort units column (should be total.effort.1 and total.effort.1.units)
```{r}
#remove non-aligned species
#add an effort_ident
wi_winnebago_fishobservations_23April2021[ sampling_method == "gillnet", .N , gear_data_notes.1]

wi_winnebago_fishobservations_23April2021[ sampling_method == "trawl", .N , gear_data_notes.1]





wi_winnebago_fishobservations_23April2021  <- wi_winnebago_fishobservations_23April2021 %>%
  mutate(total.effort.1 = case_when(sampling_method == "trawl"~ 5,
                                    sampling_method == "gillnet" ~ 1
  )
  )%>%
  mutate(total.effort.1.units = case_when(sampling_method == "trawl"~ "minutes",
                                          sampling_method == "gillnet" ~ "net-nights"
  ))%>%
  relocate(year, date.1, lake_name.1, lake_id, site_id.1, site_id.2, site_id.3, site_id.4, gear_data_notes.1, sampling_method, species.1, length.1, young_of_year, total.effort.1, total.effort.1.units, jan2023_inventoried, file_number, file_status, state, source_contact, date_recieved, source_agency, file_path, new_file_name, file_type, data_type, targeted_or_standard, individual_count, original_file_name.1, unique_row_key.1) %>% #re-order columns
uncount( weights = individual_count, .remove = T, .id = "ident_uncount") #there are no 0 counts in here. And no 0 total catch in the winnebago trawl cpue data. As such this operation is okay--we don't drop any surveys in this way.

#now add an effort_ident column
wi_winnebago_fishobservations_23April2021[ , effort_ident := .GRP , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1, sampling_method) ]

#now thin species in here:
wi_winnebago_fishobservations_23April2021[ , .N , species.1]
wi_inland_fishobservations_19Mar2021[ , .N , species.1 ][,species.1]

wi_winnebago_fishobservations_23April2021 <- wi_winnebago_fishobservations_23April2021[
  species.1 %in% wi_inland_fishobservations_19Mar2021[ , .N , species.1 ][,species.1], , ]


#saveRDS(wi_winnebago_fishobservations_23April2021 , file = "Data_and_Scripts\\Data\\output\\wi_winnebago_indiv_fish_w_effort.rds")
```
Winnebago is DONE

## Investigate inland_fishobservations file
```{r}
wi_inland_fishobservations_19Mar2021[, .N, .(noage = is.na(age))] #no fish in this file have ages... 

wi_inland_fishobservations_19Mar2021[, .N , .(nolength = is.na(length.1))] #7 million have lengths

wi_inland_fishobservations_19Mar2021[, .N, species.1] #21 species/hybrids
```

are the aged fish also in the wi_inland_fishobservations_19Mar2021 file? (MOVED TO ITS OWN SCRIPT)
```{r}
        
#This is an issue: 

# 
#         # fish_ob_test <- wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", .N ,][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),]
#         # # 650 walleye in a fyke net in this survey
#         # 
#         # 
#         # len_age_test <- wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)]
#         # # 1,137 walleye in fyke net in the same survey, but these fish have no ages, all NA..?
#         # 
#         #   ### in the example above, there are more fish in the length age file than the fish ob file... 
#         # 
#         # fish_ob_plot <- ggplot(data = fish_ob_test, aes(x = length.1))+geom_histogram(binwidth = .5)
#         # len_age_plot <- ggplot(data = len_age_test, aes(x = length.1))+geom_histogram(binwidth = .5)
#         # 
#         # library(cowplot)
#         # compare_plot <- plot_grid(fish_ob_plot, len_age_plot, labels = c("fish observations", "length age")) #same distribution of lengths
#         # 
#         # len_age_test[fish_ob_test, on = .(survey_id, sampling_method, species.1, lake_id, length.1, date.1),nomatch = NULL]
#         # 
#         # matches <- fish_ob_test[ , date.1 := as.POSIXct(date.1) ,] %>%
#         #   inner_join(len_age_test, by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1"))
#         # 
#         # 
#         # data_common1 <- generics::intersect(len_age_test, fish_ob_test)  # Apply intersect function
#         # data_common1 #384 have same survey_id, sampling_method, species, lake id, length and date
# 
# # review the data from that survey (from each source):
# wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", , ][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),][order(length.1)][ ,.N , length.1]
#   wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", , ][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),][order(length.1)]
# 
# wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)][order(length.1)][ ,.N , length.1]
#   wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)][order(length.1)]
# 
#   wi_inland_lenage_19Mar2021[ , date.1 := as.IDate(date.1) , ]
#   
# crosscheck <- merge(
#   wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
#   wi_inland_lenage_19Mar2021[ , .("laaN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
#   by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1")
#   )
# 
# plot(laaN~obsN, data = crosscheck[!is.na(obsN)])
# abline(0,1)
# 
# crosscheck[laaN > obsN] #10k cases (N of lengthXspeciesXgearXsurvey) with more obs in laa data than in the ind fish dataset
# 
# 
# #there are fish with backcalcualted ages (not what we want)
# wi_inland_lenage_19Mar2021[,.N ,(backcalculated_age)] #yes, dp, fl
# 
# #how many ages are NAs?
# wi_inland_lenage_19Mar2021[, .N,is.na(age)] #443,811 fish have ages and 239,785 fish do not have ages (35% of ages are NA)
# 
# # eliminate instances where 1) age is NA 2) age was backcalculated in length age file and 3) summarize by species in survey gear (no lengths) and try a similar test as above
# 
# crosscheck <- merge(
#   wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, sampling_method, species.1, lake_id, date.1) ],
#   wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laaN" = .N), .(survey_id, sampling_method, species.1, lake_id, date.1) ],
#   by = c("survey_id", "sampling_method", "species.1", "lake_id", "date.1"), all = T
#   )
# 
# ggplot(crosscheck, aes(laaN, obsN))+
#   geom_point()+
#   geom_abline(slope = 1, intercept = 0)
# 
# crosscheck[ , laa_subset_prop := laaN/obsN , ]
# 
# ggplot(crosscheck, aes(laa_subset_prop))+
#   geom_histogram()
# 
# crosscheck[ , summary(laa_subset_prop)]
# 
# crosscheck[laaN > obsN] #eliminating the NA ages and backcalculated ages still leaves ~ 50% of the laaN>obsN data 
# 
# 
# Qsurveys <- crosscheck[crosscheck[laaN>obsN, .N, .(survey_id, sampling_method)][ , N := NULL] , , ]
# 
# Qsurveys[ , flagged_laa_obs_Qs := laaN>obsN   ,]
# 
# 
# a <- wi_inland_fishobservations_19Mar2021[survey_id == 651 & species.1 == "yellow_perch"]
# 
# b <- wi_inland_lenage_19Mar2021[survey_id == 651 & species.1 == "yellow_perch"]
# 
# 
# 
# crosscheck <- merge(
#   wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, species.1, lake_id) ],
#   wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laaN" = .N), .(survey_id, species.1, lake_id) ],
#   by = c("survey_id", "species.1", "lake_id"), all = T
#   )
# 
# Qsurveys <- crosscheck[crosscheck[laaN>obsN, .N, .(survey_id)][ , N := NULL] , , ]
# 
# 
# 
# 
# rm(crosscheck)
# 
# wi_inland_fishobservations_19Mar2021[ ]
# colnames(wi_inland_fishobservations_19Mar2021)







```

## Connect to aged fish files
```{r}
#sampling method is simplified.
wi_inland_cpue_19Mar2021[ , unique(sampling_method)]
wi_inland_fishobservations_19Mar2021[ , unique(sampling_method)  , ]
wi_inland_lenage_19Mar2021[ ,unique(sampling_method)  ,]


wi_inland_lenage_19Mar2021[ , .N , species.1]

wi_inland_cpue_19Mar2021[ , .N ,.(survey_id, sampling_method, species.1, lake_id, total_count.1) ] #this line shows that I have defined a unique key (length = length of full data; no N>1)


#Aggregate these three to a comparable level
wi_inland_cpue_19Mar2021[ , .("cpue_n_gears" = .N, "cpue_Nfish" = sum(total_count.1)) ,.(survey_id, species.1, lake_id) ]
wi_inland_fishobservations_19Mar2021[ , .("obs_n_gears" = length(unique(sampling_method)) , "obs_Nfish" = .N), .(survey_id, species.1, lake_id) ]
wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laa_n_gears" = length(unique(sampling_method)), "laa_Nfish" = .N), .(survey_id, species.1, lake_id) ]


#this crosscheck has a resolution 1 lower than above because we haven't got full gear types in the cpue files
crosscheck <- merge(
  wi_inland_fishobservations_19Mar2021[ , .("obs_n_gears" = length(unique(sampling_method)) , "obs_Nfish" = .N), .(survey_id, species.1, lake_id) ],
  wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laa_n_gears" = length(unique(sampling_method)), "laa_Nfish" = .N), .(survey_id, species.1, lake_id) ],
  by = c("survey_id","species.1", "lake_id"), all = T
  )

crosscheck <- merge(crosscheck,
wi_inland_cpue_19Mar2021[ , .("cpue_n_gears" = .N, "cpue_Nfish" = sum(total_count.1)) ,.(survey_id, species.1, lake_id) ],
by = c("survey_id", "species.1", "lake_id"), all = T
)

crosscheck[ , cpue_obs_match := cpue_Nfish == obs_Nfish , ]
crosscheck[ , cpue_laa_match := cpue_Nfish == laa_Nfish , ]
crosscheck[ , laa_exceeds_obs := laa_Nfish>obs_Nfish ]

crosscheck[ , .N , .(cpue_obs_match)]
crosscheck[ , .N , .(cpue_obs_match, cpue_laa_match, laa_exceeds_obs)][order(cpue_obs_match, laa_exceeds_obs)]

#summarize these: 
crosscheck[ , .N , .(cpue_obs_match, cpue_laa_match, laa_exceeds_obs)][order(cpue_obs_match, laa_exceeds_obs)][ , sum(N), cpue_obs_match]
#this says that 3404/of 60027 (5.7%) surveys with both CPUE and fish obs have a mismatch in the catch between files
#the NAs are largely not of concern to me, because they are mostly from 0 speciesXsurvey obs:
crosscheck[ , .N , .(cpue_obs_match, cpue_Nfish == 0)]
#for at least one other case, a stream shocker survey is in the indiv fish obs file but not in the CPUE file. NO idea why.

crosscheck[is.na(cpue_obs_match) & is.na(cpue_Nfish) , ,]
crosscheck[survey_id == 515094436]
wi_inland_fishobservations_19Mar2021[survey_id==515094436]


# add crosscheck flag into the data:
wi_inland_fishobservations_19Mar2021[crosscheck, on = .(species.1, survey_id), flag := ifelse(laa_exceeds_obs==T, "laa exceeds obs", "")  ]

wi_inland_fishobservations_19Mar2021[ , .N , flag ]



#now bring the laa data back into the obs file
# Thin to only age obs and not backcalculated: 
wi_inland_lenage_19Mar2021 <- wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl") ]
#prep date col
wi_inland_lenage_19Mar2021[ , date.1 := as.IDate(date.1,format = "%m/%d/%Y"),]

# try a rounding to tenth inches to clean up the age link
wi_inland_lenage_19Mar2021[, length.1 := round(length.1,1) ]
wi_inland_fishobservations_19Mar2021[, length.1 := round(length.1,1) ]

#add identifiers for individual fish-lengths in a survey 
wi_inland_fishobservations_19Mar2021[ , id_indv_win_len := seq_len(.N) , .(lake_id, date.1, sampling_method, survey_id, species.1, length.1) ] #assign a id to each ind fish observed within a given length
wi_inland_lenage_19Mar2021[ , id_indv_win_len := seq_len(.N) , .(lake_id, date.1, sampling_method, survey_id, species.1, length.1) ]  #assign a id to each ind fish observed within a given length

#drop unneeded cols from age data
wi_inland_lenage_19Mar2021 <- wi_inland_lenage_19Mar2021[ , .(lake_id, date.1, sampling_method, survey_id, species.1, length.1, weight.1, age, aging_structure.1, sex, reproductive_condition_notes, aging_data_notes.1, id_indv_win_len, original_file_name.1) , ]
#drop unneeded cols from indivfish table
wi_inland_fishobservations_19Mar2021[ , age := NULL , ]

#cleanup ws to prep for heavy merge
rm(cde, crosscheck, gear_table, names, unusedbits, wi_inland_cpue_19Mar2021, cols, filei, files_list, i, maxn, n)
#merge/do left join 
wi_inland_fishobservations_19Mar2021 <- 
merge(wi_inland_fishobservations_19Mar2021,
      wi_inland_lenage_19Mar2021[],
      by =  c("lake_id", "date.1", "sampling_method", "survey_id", "species.1", "length.1", "id_indv_win_len"),
      all = T,
      suffixes = c("_indivfish","_agedfish")) # works

wi_inland_fishobservations_19Mar2021[  , .N  , .("Has_Observatinon_Dat" = !is.na(original_file_name.1_indivfish), "Has_age_dat" = !is.na(age))   ]


#drop any age data where unable to match to fishobservations
# wi_inland_fishobservations_19Mar2021 <- wi_inland_fishobservations_19Mar2021[!is.na(original_file_name.1_indivfish) , ,]

wi_inland_fishobservations_19Mar2021[ !is.na(age) , .N , .(lake_id,date.1) ]


# fwrite(crosscheck, file = "Data_and_Scripts/Data/output/crosscheck_cpue_fishobs_lengthage.csv")
rm(wi_inland_lenage_19Mar2021)

```


## Join wi_inland_fishobservations to the wi_inland_effort
- note, unique key is: .(lake_id, date.1, sampling_method, and sample_id.1) (year can be used too)
```{r}
#key check
wi_inland_effort_19Mar2021[ , .N , .(lake_id, date.1, sampling_method, survey_id, sample_id.1) ]

#still missing some effort--save that from the trash bin

wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(sample_time_notes.1, "NA"), `:=` (total.effort.1 = word(sample_time_notes.1, -1, sep = ":"), total.effort.1.units = "minutes")  , ]

wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(sample_time_notes.3, "NA"), `:=` (total.effort.1 = word(sample_time_notes.3, -1, sep = ":"), total.effort.1.units = "hours")]

wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(gear_data_notes.9, "NA"), `:=` (total.effort.2 = word(gear_data_notes.9, -1, sep = ":"), total.effort.2.units = "number_of_nets")]

wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !str_detect(gear_data_notes.11, "NA"), `:=` (total.effort.2 = word(gear_data_notes.11, -1, sep = ":"), total.effort.2.units = "number_units_gear_amt")]

#some vars contain no additional data
wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !is.na(effort), .N , effort]

wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !is.na(sample_time_min), .N , sample_time_min]

wi_inland_effort_19Mar2021[is.na(total.effort.1) & is.na(total.effort.2) &
                             !is.na(number_of_nets), .N , number_of_nets]




# choose keeper cols from effort
wi_inland_effort_19Mar2021 <- wi_inland_effort_19Mar2021[ , .(lake_id, date.1, sampling_method, survey_id, sample_id.1, simple_gear,
                                                              distance, distance_units, total.effort.1, total.effort.1.units, total.effort.2, total.effort.2.units, 
                                                              target_species, secondary_target_species, survey_type.1, survey_type.2, gear_data_notes.10, water_temp, water_temp_units, 
                                                              water_clarity, water_clarity_units, lat_start, lon_start, lat_end, lon_end, 
                                                              original_file_name.1
                                                              ) , ]




#change date to IDate
wi_inland_effort_19Mar2021[ , date.1 := as.IDate(date.1,format = "%m/%d/%Y"),]


names(wi_inland_effort_19Mar2021)




wi_inland_fishobservations_19Mar2021 <- merge(wi_inland_fishobservations_19Mar2021, wi_inland_effort_19Mar2021, by = c("lake_id", "date.1", "sampling_method", "survey_id", "sample_id.1"), suffixes = c("_indivfish", "_effort"), all = T)

#saveRDS(wi_inland_fishobservations_19Mar2021, file = "Data_and_Scripts\\Data\\output\\wi_indiv_fish_w_effort_with_ages.rds")

rm(wi_inland_effort_19Mar2021)


#clean up this data product:
colnames(wi_inland_fishobservations_19Mar2021)

#county
colnames(wi_inland_fishobservations_19Mar2021)[str_detect(colnames(wi_inland_fishobservations_19Mar2021), "county")]


#lake_name
colnames(wi_inland_fishobservations_19Mar2021)[str_detect(colnames(wi_inland_fishobservations_19Mar2021), "lake_name")]


#year
colnames(wi_inland_fishobservations_19Mar2021)[str_detect(colnames(wi_inland_fishobservations_19Mar2021), "year")] #what's here for year data?
wi_inland_fishobservations_19Mar2021[ , .N , is.na(date.1) ]
wi_inland_fishobservations_19Mar2021[ , .N , .(is.na(date.1), is.na(year)) ] #no cases of na date where year can cover, drop year
wi_inland_fishobservations_19Mar2021[ , year := NULL , ]


#survey_id
colnames(wi_inland_fishobservations_19Mar2021)[str_detect(colnames(wi_inland_fishobservations_19Mar2021), "survey_id")] #what's here for this var name?


#survey_type
colnames(wi_inland_fishobservations_19Mar2021)[str_detect(colnames(wi_inland_fishobservations_19Mar2021), "survey_type.1")] #what's here for this var name?
#consolidate if possible
wi_inland_fishobservations_19Mar2021[ survey_type.1_indivfish != survey_type.1_effort , .N ,  ] #any disagreememnt among non-NA fields
wi_inland_fishobservations_19Mar2021[  , .N , .(indvNA = is.na(survey_type.1_indivfish), effNA = is.na(survey_type.1_effort) ) ] # whats the NA coverage look like?
wi_inland_fishobservations_19Mar2021[ , .N ,  .(survey_type.1_indivfish, survey_type.2_indivfish, survey_type.1_effort, survey_type.2_effort  )]

#mostly disagreement, need to retain all. 

#state
colnames(wi_inland_fishobservations_19Mar2021)[str_detect(colnames(wi_inland_fishobservations_19Mar2021), "state")] #what's here for this var name?

colnames(wi_inland_fishobservations_19Mar2021)

setnames(wi_inland_fishobservations_19Mar2021, "original_file_name.1" ,"original_file_name.1_effort")

not_garbage <- c( 
  "state", "county", "lake_name.1", "lake_id", "date.1", "survey_id", "survey_type.1_indivfish", "survey_type.2_indivfish", "survey_type.1_effort", "survey_type.2_effort",
  "sampling_method", "sample_id.1", "simple_gear", "target_species_effort", "target_species_indivfish", "secondary_target_species",                   
  "total.effort.1", "total.effort.2", "total.effort.1.units", "total.effort.2.units", "distance", "distance_units",
  "gear_data_notes.10", "water_temp", "water_temp_units", "water_clarity", "water_clarity_units", "lat_start", "lon_start", "lat_end", "lon_end",
  "species.1", "length.1", "length_unit.1", "age", "aging_structure.1_agedfish", "weight.1_indivfish", "weight.1_agedfish", "weight_unit.1",
  "sex_agedfish", "sex_indivfish", "young_of_year", "id_indv_win_len", "aging_data_notes.1", "reproductive_condition_notes",
  "flag",
  "original_file_name.1_agedfish", "original_file_name.1_indivfish", "original_file_name.1_effort"
  )

# reorder cols
# setcolorder(wi_inland_fishobservations_19Mar2021, not_garbage)

#keep only specified not garbage
wi_inland_fishobservations_19Mar2021 <- wi_inland_fishobservations_19Mar2021[ , ..not_garbage , ]
 
```



## Bind winnebago and inland data together
```{r}
#prep for merge

#nix all unnneeded dat from mem

rm(not_garbage)


#ensure all formats are DT. 
str(wi_inland_fishobservations_19Mar2021)
str(wi_winnebago_fishobservations_23April2021)



#fix date
wi_winnebago_fishobservations_23April2021 [ , date.1 := as.IDate(date.1,format = "%Y/%m/%d"),]


wi_inland_fishobservations_19Mar2021 <- rbindlist(list(wi_inland_fishobservations_19Mar2021, wi_winnebago_fishobservations_23April2021 ),
                               fill = TRUE,
                               use.names = TRUE)

rm(wi_winnebago_fishobservations_23April2021 )

```

## clean up the data product:
```{r}
colnames(wi_inland_fishobservations_19Mar2021)

setnames(wi_inland_fishobservations_19Mar2021, "original_file_name.1", "original_file_name.1_winnebago")


#winnebago sample idents -- can I generate some better sample loc than these composite things?
wi_inland_fishobservations_19Mar2021[ , .N , .(is.na(site_id.1), is.na(site_id.2), is.na(site_id.3), is.na(site_id.4))]
wi_inland_fishobservations_19Mar2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, gear_data_notes.1, sampling_method)]

wi_inland_fishobservations_19Mar2021[ , max(sample_id.1, na.rm = T) ,] #current max value in the data


# The winnebago effort ident is similar to the sample_id.1 from WI DNR (visit.fish.seq.no) and is an effort grouping variable.
wi_inland_fishobservations_19Mar2021[is.na(sample_id.1), .N , .(original_file_name.1_agedfish, original_file_name.1_indivfish, original_file_name.1_effort, original_file_name.1_winnebago) ] 


#but for winnebago, we actually have sub_effort.1 (effort_ident is a sample out of a single net on winnebago on a date) Fix that:
  wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name.1_winnebago) , length(unique(effort_ident))  , .(date.1 )  ]
  wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name.1_winnebago), sub_effort_ident := effort_ident , ]

#build a grouping var for the total effort (gearxdatexwinnebago)  
  wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name.1_winnebago) , total_effort_ident := .GRP + 778618  , .(date.1, sampling_method) ] #start at the current sample_id.1 value
  
#now roll the rest of the dataset's sample_ids into that field
  wi_inland_fishobservations_19Mar2021[ is.na(total_effort_ident), total_effort_ident := sample_id.1 , ]
  wi_inland_fishobservations_19Mar2021[, `:=` (effort_ident = NULL, sample_id.1 = NULL) ,  ]

#does that effort grouper work for total eff 1 & 2 ?
wi_inland_fishobservations_19Mar2021[ , length(unique(total.effort.1)) , total_effort_ident ][ , .N , V1] #yes
wi_inland_fishobservations_19Mar2021[ , length(unique(total.effort.2)) , total_effort_ident ][ , .N , V1] #yes

#all winnebago sub_effort data are contained in the total effort column (will need to calc new total effort vals)
    wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name.1_winnebago) , `:=` (sub_effort_1 = total.effort.1, sub_effort_1_units = total.effort.1.units)  , ]
    wi_inland_fishobservations_19Mar2021[ , sub_effort_1 := as.integer(sub_effort_1) ,]
    

#for winnebago, total effort from a survey is a sum of how many 5 minute trawls were on that date
wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name.1_winnebago) ,
                                      .("n_uniquesubidents" = length(unique(sub_effort_ident)), "unique_eff" = length(unique(sub_effort_1))) , .(total_effort_ident, sampling_method) ] #these are all 1 unit of 5 minute trawl or 1 net-night of gillnet


#calculate trawl efforts
wi_inland_fishobservations_19Mar2021[  !is.na(original_file_name.1_winnebago) & sampling_method == "trawl" , `:=` (total.effort.1 = length(unique(sub_effort_ident))*5,
                                                                                                      total.effort.1.units = "minutes"),
                                                                                                      .(total_effort_ident) ]

#calculate gillnet efforts
wi_inland_fishobservations_19Mar2021[  !is.na(original_file_name.1_winnebago) & sampling_method == "gillnet" , `:=` (total.effort.1 = length(unique(sub_effort_ident)),
                                                                                                      total.effort.1.units = "net-nights"),
                                                                                                      .(total_effort_ident) ]

wi_inland_fishobservations_19Mar2021[ !is.na(total_effort_ident) , .("nfish" = .N, unique(total.effort.1), unique(total.effort.1.units)) , .(total_effort_ident, sampling_method)]
  
  
  

not_garbage <- c( 
  "state", "county", "lake_name.1", "lake_id", "date.1", "survey_id", "survey_type.1_indivfish", "survey_type.2_indivfish", "survey_type.1_effort", "survey_type.2_effort",
  "sampling_method",  "simple_gear", "target_species_effort", "target_species_indivfish", "secondary_target_species",                   
  "total_effort_ident", "total.effort.1", "total.effort.2", "total.effort.1.units", "total.effort.2.units", "distance", "distance_units",
  "gear_data_notes.10", "water_temp", "water_temp_units", "water_clarity", "water_clarity_units", "lat_start", "lon_start", "lat_end", "lon_end", "site_id.1", "site_id.2", "site_id.3", "site_id.4", "gear_data_notes.1","sub_effort_ident","sub_effort_1", "sub_effort_1_units",
  "species.1", "length.1", "length_unit.1", "age", "aging_structure.1_agedfish", "weight.1_indivfish", "weight.1_agedfish", "weight_unit.1",
  "sex_agedfish", "sex_indivfish", "young_of_year", "id_indv_win_len", "aging_data_notes.1", "reproductive_condition_notes",
  "flag",
  "original_file_name.1_agedfish", "original_file_name.1_indivfish", "original_file_name.1_effort", "original_file_name.1_winnebago"
  )


setcolorder(wi_inland_fishobservations_19Mar2021, not_garbage) #reorder from this list before axe-ing the garbage cols

wi_inland_fishobservations_19Mar2021 <- wi_inland_fishobservations_19Mar2021[ , ..not_garbage , ]

#parquet version 2, dated 26 Oct 2023 3:37pm


#clean up column names - checked. not the problem
setnames(wi_inland_fishobservations_19Mar2021,
         colnames(wi_inland_fishobservations_19Mar2021) ,
         make_clean_names(colnames(wi_inland_fishobservations_19Mar2021)))




#flag some crazy dates
wi_inland_fishobservations_19Mar2021[ , summary(date_1) , ]
wi_inland_fishobservations_19Mar2021[ year(date_1) < 1938 |
                                        year(date_1) > 2023, unique(date_1) , ]



#first clean up flags then add new flag note. Not the problem
wi_inland_fishobservations_19Mar2021[ , .N , flag]
wi_inland_fishobservations_19Mar2021[is.na(flag) | flag == "", .N]
wi_inland_fishobservations_19Mar2021[is.na(flag) | flag == "", flag := NA, ]
wi_inland_fishobservations_19Mar2021[year(date_1) < 1938 |
                                        year(date_1) > 2023 , flag := ifelse(is.na(flag), "bad_date" , fpaste(flag, "bad_date", sep = ";" )) ,]



# add NHDids. checked. not the problem.
wi_inland_fishobservations_19Mar2021 <- local_to_nhdhr(wi_inland_fishobservations_19Mar2021, from_colname = "lake_id", states = "wi")
#check coverage
wi_inland_fishobservations_19Mar2021[ !is.na(lake_id) , .N , is.na(nhdhr.id)]
#report unmatched from mwlaxeref
wi_inland_fishobservations_19Mar2021[ !is.na(lake_id) & is.na(nhdhr.id), .N , .(lake_id, lake_name_1) ]
#fix name
setnames(wi_inland_fishobservations_19Mar2021, "nhdhr.id", "nhdhr_id")




#add a nothing_caught column. checked. not the problem.
wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name_1_effort) & is.na(species_1), nothing_caught := TRUE  ,  ]
wi_inland_fishobservations_19Mar2021[ !is.na(original_file_name_1_effort) & !is.na(species_1), nothing_caught := FALSE  ,  ]

# wi_inland_fishobservations_19Mar2021[nothing_caught == T, unique(total_effort_ident)]
wi_inland_fishobservations_19Mar2021 %>% 
  filter(nothing_caught == T) %>% 
  distinct(total_effort_ident)


# running these two lines will cause the dataset to blow up in size at saving to parquet... no idea why, 
# #should only be one instance for each record of unsucessful effort
# wi_inland_fishobservations_19Mar2021[ total_effort_ident %in% wi_inland_fishobservations_19Mar2021[nothing_caught == T, unique(total_effort_ident)], .N , total_effort_ident
# ][N>1]
# 
# wi_inland_fishobservations_19Mar2021[total_effort_ident == 726827] #these are two shitty records








```


## Export a WI file, Import a WI file, Reformat to Arrow

```{r}
# saveRDS(wi_inland_fishobservations_19Mar2021, "E:/My Drive/Documents/UMN/Hansen Lab/Rprojects/CASC_Fish_Climate/Data_and_Scripts/Data/output/wi_flat_effort_indivfish_merge.rds")

# wi_inland_fishobservations_19Mar2021 <- readRDS("E:/My Drive/Documents/UMN/Hansen Lab/Rprojects/CASC_Fish_Climate/Data_and_Scripts/Data/output/wi_flat_effort_indivfish_merge.rds")

# wi_dat <- as_arrow_table(wi_inland_fishobservations_19Mar2021)


#arrow file print:
# wi_dat
# 
# #now dplyr
# glimpse(wi_dat)
# 
# #try a piped operation (note the "lazy evaluation" means require collect())
# WI_indiv_fish_w_effort %>% 
#   group_by(species.1) %>%
#   summarise(sum(!is.na(weight.1)))%>%
#   collect()%>%
#   print(n = 22)
# 
# 
# 
# colnames(wi_data)


```


#export as parquet file
```{r}

# setDT(wi_inland_fishobservations_19Mar2021)
# wi_inland_fishobservations_19Mar2021 <- as_tibble(wi_inland_fishobservations_19Mar2021)

write_dataset(dataset = wi_inland_fishobservations_19Mar2021, path = "Data_and_Scripts/Data/output/wi_file_arrow", format = "parquet")

wi_data <- open_dataset(sources = "Data_and_Scripts/Data/output/wi_file_arrow/")

glimpse(wi_data)
```


# Priority column tidying 
```{r}

#print all column names
wi_data %>%
  names() %>%
  sort() %>% make_clean_names()


wi_data %>% 
  group_by(survey_type.1_indivfish) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))




#species column
#cols containing "species" (skipping pipe to names includes a format report from arrow)
wi_data %>% 
  select(contains("species"))
  # %>%
  # names()
#view unique names of species:
wi_data %>% 
  select(species.1) %>% 
  unique() %>%
  arrange(species.1) %>%
  collect() %>%
  print(n = nrow(.))

wi_data %>% 
  filter(lake_name.1 != "lake_winnebago") %>% 
  group_by(species.1) %>% 
  summarise( n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))

wi_data %>% 
  filter(is.na(species.1)) %>%
  select(survey_id, sampling_method, total.effort.1, total.effort.1.units, total_effort_ident, lake_name.1, lake_id, date.1) %>% 
  collect() %>% 
  {species_NA_surveys <<- . }




#these look fine to me. They comply with the Data Agg Doc specs here: https://docs.google.com/document/d/1Ax_4vmsIqDuWU8wtxBRXv73mbLB_TjT4B2gG6Yp_tkQ/edit?pli=1#heading=h.f6zxnh5xaf40

#location columns
#lake_id & lake_name
wi_data %>%
  select(contains("lake"))%>%
  unique()%>%
  collect()

#all lake loc data:
#here I review glimpse(wi_data) and call only the location-ey fields
wi_data %>% 
  select(lake_id, lake_name.1, state, county, site_id.1, site_id.2, site_id.3, site_id.4 )%>%
  unique() %>%
  compute()

# I suspect the site IDs are winnebago specific
wi_data %>% 
  filter( !is.na(site_id.1)) %>% 
  select(lake_name.1) %>% 
  unique() %>% 
  collect()
# it is. drop that from the location data, above

#here I review glimpse(wi_data) and call only the location-ey fields
wi_data %>% 
  select(lake_id, lake_name.1, state, county)%>%
  unique() %>%
  compute()

#now check these fields one at a time (lake_name and id are done)
wi_data %>% 
  select(state) %>% 
  unique() %>%
  collect()
#view unique names of counties:
wi_data %>% 
  group_by(county) %>% 
  summarize( n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))

# NA counties are a diverse set of waterbodies:
wi_data %>% 
  filter( !is.na(county)) %>% 
  select(lake_name.1) %>% 
  unique() %>% 
  collect() %>% 
  print( n = 100)


#now review the date columns
#fields with "date"
wi_data %>%
  select(contains("date"))
#date.1 is the only useful column here:

#any NAs in date? yes, they are all from aged fish that went unmatched to a survey
wi_data %>%
  filter(is.na(date.1))%>%
  group_by(is.na(original_file_name.1_agedfish)) %>% 
  count() %>% 
  collect()

wi_data %>%
  select(date.1)%>%
  compute() 

wi_data %>%
  select(date.1)%>%
  collect() %>% 
  summary() 

# seems unlikely that there are fish data from 1899...
wi_data %>%
  filter(date.1 < "1899-1-1")%>%
  select(date.1) %>% 
  unique() %>% 
  collect() 

wi_data %>% 
  filter(lake_id == 99999) %>% 
  select(lake_name.1) %>% 
  unique() %>% 
  collect()

wi_data %>% filter(year(date.1)<1938) %>% collect() %>% group_by(original_file_name.1_agedfish) %>% count()# these are mostly aged fish
wi_data %>% filter(year(date.1)<1938 & is.na(original_file_name.1_agedfish)) %>% collect() 



#definitely odd, but I don't know that we have any way of determining the true date in these. Let's flag those dates as questionable

wi_data %>%
  # filter(date.1 < "1940-1-1") %>% 
  mutate(FLAGGED_date_questionable = date.1 < "1930-1-1") %>% 
  select(FLAGGED_date_questionable ) %>% 
  compute()

#in order to amend the parquet file, I'd need to load it into R, add that column then re-write to disk. 


#gear
wi_data %>% 
  select(sampling_method) %>% 
  unique() %>% 
  compute() %>% 
  collect() %>% 
  print(n = nrow(.))

wi_data %>% 
  group_by(sampling_method) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print( n = nrow(.))  

wi_data %>% 
  filter(sampling_method == "vertical_gill_net") %>% 
  group_by(species.1) %>% 
  summarise(n = n()) %>% 
  collect()


wi_data %>% 
  filter(sampling_method == "vertical_gill_net" & !is.na(original_file_name.1_effort)) %>% 
  group_by(survey_id, date.1, lake_name.1, lake_id, original_file_name.1_effort, original_file_name.1_indivfish, original_file_name.1_agedfish, original_file_name.1_winnebago) %>% 
  summarise(n = n()) %>% 
  collect() %>% print(n = nrow(.))

#target species
wi_data %>% 
  group_by(target_species_indivfish) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print(n = nrow(.))

wi_data %>% 
  group_by(target_species_effort) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print(n = nrow(.))
#counts are different for fish and effort

wi_data %>% 
  mutate(same_target = ifelse(target_species_effort == target_species_indivfish, "Same", "Different")) %>% 
  group_by(same_target) %>% 
  count() %>% 
  collect()
#no conflicting rows between effort and fish, but data might be missing from one or the other

wi_data %>% 
  filter(is.na(target_species_effort) & !is.na(target_species_indivfish)) %>% 
  count(species.1) %>% 
  collect()
#only one case where effort is na but fish is not

wi_data %>% 
  filter(!is.na(target_species_effort) & is.na(target_species_indivfish)) %>% 
  count(species.1) %>% 
  collect()
#33657 cases where fish is na but effort is not - ironically the species is also na 

wi_data %>% 
  filter(is.na(target_species_effort) & is.na(target_species_indivfish)) %>% 
  summarise(n = n()) %>% 
  collect()
#this tells us that the effort column should be used for the targeted data - there is only one case where indivfish has data and effort doesn't. All other cases are na for both

wi_data %>% 
  select(target_species_effort) %>% 
  unique() %>% 
  compute() %>% 
  collect() %>% 
  print(n = nrow(.))


#length
wi_data %>% 
  group_by(species.1) %>% 
  summarise(mean = mean(length.1, na.rm = T), min = min(length.1, na.rm = T), max = max(length.1, na.rm = T)) %>% 
  collect() %>% 
  print(n = nrow(.))

#big walleye and pike?
wi_data %>% 
  filter((length.1 > 900 & species.1 == "walleye") |
          (length.1 > 2000 & species.1 == "northern_pike")) %>% 
  collect()
#walleye and pike are big have units of inches but appear to be in mm

wi_data %>% 
  group_by(length_unit.1) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  arrange(n) %>% 
  print(n = nrow(.))
#units are in inches, 4153536 obs that are na for length unit

#Are the cases of na length unit when length is na?
wi_data %>% 
  filter(is.na(length.1) & is.na(length_unit.1)) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))
#3928844 are missing both length and length unit

#cases where there are lengths without any length units
wi_data %>% 
  filter(!is.na(length.1) & is.na(length_unit.1)) %>% 
  summarise(n = n()) %>% 
  collect() %>% 
  print(n = nrow(.))
#224692 have a length but are missing the unit

#see if this file has my QC flag in it
wi_data %>%
  select(contains("flag"))


````

# Test a filtering approach
``` {r}

#explain the no fish caught situation in these data:
# if there was nothing caught in a gear within a survey (aka. nothing that was a species of interest to us--recall that we told them to not send everything but just the species of interest to us)
#examine the species.1 = NA cases; 

#how many cases of total zero survey efforts: MORE THAN HALF OF THESE!!!
wi_data %>%
  filter(!is.na(original_file_name.1_effort)) %>% 
  group_by(is.na(species.1), survey_id)%>%
  count() %>% 
  collect() %>% 
  group_by(`is.na(species.1)`) %>% 
  count()

#An important result, given that there are ALL KINDS of crazy survey types in here that may or may-not ever catch the key species we were interested in. 
wi_data %>% count(sampling_method) %>% collect()
#how many cases of total zero survey efforts: MORE THAN HALF OF THESE!!!


#how many cases of total zero survey efforts: MORE THAN HALF OF THESE!!!
wi_data %>%
   filter(!is.na(original_file_name.1_effort), sampling_method == "fyke_net") %>% 
   group_by(is.na(species.1), survey_id)%>%
   count() %>% 
   collect() %>% 
   group_by(`is.na(species.1)`) %>% 
   count()

#review the cases where boomshocking was not successful
wi_data %>%
  filter(!is.na(original_file_name.1_effort) & sampling_method == "boom_shocker" & is.na(species.1)) %>% 
  group_by(total.effort.1,total.effort.1.units, survey_type.1_indivfish,survey_type.2_indivfish,survey_type.1_effort,survey_type.2_effort, target_species_effort,target_species_indivfish,secondary_target_species ) %>%
  summarise(n = n()) %>% 
  collect() %>% 
  { . ->> unsucessfulboomshocking}











````





















