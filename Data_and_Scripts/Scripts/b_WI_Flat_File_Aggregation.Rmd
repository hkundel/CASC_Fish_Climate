---
title: "b_WI_Flat_File_Aggregation"
author: "Holly Kundel & Mike Verhoeven"
date: "`r Sys.Date()`"
output: html_document
---
Outstanding work:

DNOE  1. Fix data import to squash warnings and add ticker
      2. Button up the column name cleaning section of the file
      2b. consider a reformat to Arrow for speed
      3. Add section for data proofing
DONE  4. Lake winnebago data are not yet "uncount" ed
      5. Need to tidy up as many colnames as possible at each merge phase to prevent huge buildup of shit at the end (see current section at line 550ish)

# Preamble

libraries
```{r}
library(arrow)
library(readr)
library(dplyr)
library(stringr)
library(data.table)
library(janitor)
library(tidyr)
library(lubridate)
library(ggplot2)

options(scipen = 999)
```


# Load Data

* First run CASC Data Explainer
* note Holly has to change "E" in file paths to "D" 
* This data import block takes about 10 minutes to run
* needs an update to nix warnings (see Github issue on this)
```{r}
#generate a file list to import
files_list <- list.files(path = "E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data", pattern = ".+\\.csv") #grabs only.csv files
#grabs only.csv files
files_list

#object for use in loop (simple length of file list)
n <- length(files_list)

for(i in 1:n) {
  #i = 3
  filei <- word(gsub(".csv","", files_list[i]), start = -1, sep = fixed("/"))
  #this does those two steps in one package
  assign(filei ,
          fread(paste0("E:/Shared drives/Hansen Lab/RESEARCH PROJECTS/Fish Survey Data/WI_Data/wi_raw_disaggregated_data/",
                                          files_list[i])))
  
  # if the file is a crosswalk, do not rename anything, just loop to the confirm import line
  if(str_detect(filei, "crosswalk")) {  #confirm import of files:  
    print(paste(filei ,"added to workspace" ))  
    #confirm import of files:  
    print(paste(i ,"files added to workspace" )) ; next}
  
  
  # note we want to review a sorted list of column names to check misspelling etc.
  # we still need to use the columns with names like col_name_length_in, or known_units
  
  
  cde %>% # call data explainer file
    filter(`new_file_name`== filei)%>% #keep only the row relevant to this file
    select_if(~ !any(is.na(.))) %>% 
    transpose(keep.names = "newname") %>% 
    rename("oldname" = V1) %>% 
    assign("names", ., envir = .GlobalEnv)
  
  #see if any column names will not have a match! 
  # IF any pop FALSE, force stop and revist of data explainer ()
  # - e.g., named something "total catch" when actual column name was "total_catch"
  print(
    cbind(colnames(get(filei)),
          colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]
    )
  )
  
    
  # break the loop if the current file has column names not in the data explainer
  # if (all(cbind(colnames(get(filei)),  colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ])[,2]) == FALSE ) break
  if (all(colnames(get(filei)) %in% names[ !str_detect(newname,"unique_row_key"), oldname, ]) == FALSE ) break
  
  
  # append old col names into new "notes" columns:
  get(filei)[ , (names[ str_detect(newname, "notes") , oldname   ,  ]) := Map(paste, colnames(.SD), .SD, sep = ':') , .SDcols =  names[ str_detect(newname, "notes") , oldname   ,  ] ]
  
  #now rename that file's colnames
  setnames(get(filei), colnames(get(filei)), names[!str_detect(newname,"unique_row_key")] [match(names(get(filei)),names[!str_detect(newname,"unique_row_key"),oldname]), newname] )
  
  #append all other data from data explainer
  unusedbits <- 
    data.table(
      matrix(
        rep(names[ !newname %in% colnames(get(filei)) , oldname , ],
            each = nrow(get(filei))
        ),
        nrow = nrow(get(filei)),
        dimnames = list(rep(NA,nrow(get(filei))),
                        names[ !newname %in% colnames(get(filei)) , newname , ])
        )
      )
  
  #add all not yet used columns from data explainer:
  get(filei)[ , (names[ !newname %in% colnames(get(filei)) , newname , ]) := unusedbits[] ]

  #confirm import of files:  
  print(paste(filei ,"added to workspace" ))  
  #confirm import of files:  
  print(paste(i ,"files added to workspace" )) 

  
} 

  #confirm import of files:  
  print(paste(i ,"files added to workspace" ))
  #confirm import of files:  
  print(paste(n-i ,"remaining to be added" )) 

```

# Identify Which data types are in each file
[1] "wi_inland_cpue_19Mar2021.csv"                  ~ CPUE (Effort and Catch)                 
[2] "wi_inland_effort_19Mar2021.csv"                ~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)          
[3] "wi_inland_fishobservations_19Mar2021.csv"      ~ Individual Fish    
[4] "wi_inland_lenage_19Mar2021.csv"                ~ Individual Fish             
[5] "wi_winnebago_cpue_23Apr2021.csv"               ~ CPUE (just has CPUE and units for CPUE)       LINE 338 - LINE 356 shows that this file is redundant and unneeded.       
[6] "wi_winnebago_fishobservations_23April2021.csv" ~ Individual Fish NO THIS IS NOT!!!!!!!!!


# Effort Data

Inland effort data exploration ([2] "wi_inland_effort_19Mar2021.csv"~ True Effort (as distance, sample_time_notes.1, gear_data_notes.9)   )
```{r}
# Only one "True Effort" file (each row is a gear in a survey): 'wi_inland_effort_19Mar2021'

# Rest of the files with Effort also have catch (species in a gear with a survey)

# CPUE/Effort Files with Catch: "wi_inland_cpue_19Mar2021" 

# wi_winnebago_cpue_23Apr2021.csv ~ only has CPUE and CPUE units. No catch or effort
    # effort for all winnebago surveys is "5 min trawl"
    


#investigate the one true effort file we have

# gears present
wi_inland_effort_19Mar2021[ ,.N , sampling_method ]
  # 53 unique gears: electrofishing, nets, hook and line, traps, trawls, etc.

wi_inland_effort_19Mar2021[sampling_method=="seine" , ,  ][gear_data_notes.9 == "number.of.nets:NA"]

# where do actual efforts live for each type of gear
wi_inland_effort_19Mar2021[ ,.N , .(sampling_method, distance, sample_time_notes.1, gear_data_notes.9) ]
  # it appears any kind of shocking effort is in "sample_time_notes.1 and "distance"
  # net effort is in "gear_data_notes.9"

#whats this line do? 
# wi_inland_effort_19Mar2021[ ,.(sampling_method, distance, gear_data_notes.1, gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, gear_data_notes.5, gear_data_notes.6, gear_data_notes.7, gear_data_notes.8, gear_data_notes.9, gear_data_notes.10, gear_data_notes.11, gear_data_notes.12, gear_data_notes.13, sample_time_notes.1, sample_time_notes.2) , sampling_method]

#is survey_id unique to each survey?
wi_inland_effort_19Mar2021[ ,  , survey_id] # Holly E said to be cautious about survey ID #THIS LINE JUST PRINTS THE ENTIRE DATASET
  wi_inland_effort_19Mar2021[ , .N , survey_id]
    # yes! NO THE SURVEY ID IS NOT A UNIQUE KEY HERE
wi_inland_effort_19Mar2021[ ,  , .(lake_id, date.1, sampling_method)] #THIS LINE JUST PRINTS THE ENTIRE DATASET
  wi_inland_effort_19Mar2021[ , .N  , .(lake_id, date.1, sampling_method)]
  # lake_id, date.1, and sampling_method also work as a key
  #NO THEY DONT

# does "year" work as well as "date.1" ?
wi_inland_effort_19Mar2021[ , , .(lake_id, year, sampling_method)] #THIS LINE JUST PRINTS THE ENTIRE DATASET TRY THESE:
      wi_inland_effort_19Mar2021[ ,.N , .(lake_id, sampling_method)]
      wi_inland_effort_19Mar2021[ , .N , .(lake_id, year, sampling_method)]
  # for the inland data, year works just as well
      #^NOT RIGHT
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, date.1, sampling_method)]
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, year, date.1, sampling_method)] # why does year add identity to these data!?!??!
          wi_inland_effort_19Mar2021[ , unique(date.1) , ]
          wi_inland_effort_19Mar2021[ word(date.1, -1, sep = "/") != year , . (date.1, year) , ] #in the orginal data, date == "sample date", whereas year == "survey year"
          #reviewing a bit of this data suggests that there are surveys that lasted multiple years (like maybe they were mark-recpature or cohort tracking mortality estimating special surveys. Not sure TBH)
        
        
       #NEED TO VERIIFY HERE THAT THE VARIABLE VISIT.FISH.SEQ.NO is a surveyXgearID
        wi_inland_effort_19Mar2021[  , .N  , .(sample_id.1)] # so obviously this is a good key
        wi_inland_effort_19Mar2021[ , .N  , .(lake_id, survey_id, year, date.1, sampling_method)] #try to understand what makes a row (sample-wise)
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)] [ , hist(N) ,]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method)] [ , summary(N) ,]
        wi_inland_effort_19Mar2021[ , .N , .(county, lake_name.1, lake_id, survey_id, year, date.1, sampling_method,
                                             #gear data adds ident value to the set
                                             distance, sample_time_notes.1, sample_time_notes.2, sample_time_notes.3, 
                                             gear_data_notes.1, 
                                             gear_data_notes.2, gear_data_notes.3, gear_data_notes.4, 
                                             gear_data_notes.5, 
                                             gear_data_notes.6, 
                                             gear_data_notes.7, 
                                             gear_data_notes.8, 
                                             gear_data_notes.9, 
                                             gear_data_notes.10, 
                                             gear_data_notes.11, 
                                             gear_data_notes.12, gear_data_notes.13, gear_data_notes.14, gear_data_notes.15)]
      # IMO this suggests that any effort data loaded into the pipeline ought to REQUIRE an input (allow many?) of total effort. 
      # gear_data_notes 1:8 and 12 through 15 are all electro-fishing details
      # gear_data_notes 10: depth
        
      #as far as I can tell, they'd often deploy the same gear on a single day in a given survey. Those multiple instances of same gear seem to be the way that sample_id.1 arises. 
      wi_inland_effort_19Mar2021[  , .N  , .(sample_id.1)] # so this is our key to the fish dat, I think. 
        
        
        
```

simplify gear types and move notes over to effort columns
```{r}

# Work on making an "effort" and "effort units" column
gear_table <- wi_inland_effort_19Mar2021[ ,.N , sampling_method ]

gear_table[str_detect(sampling_method, "shock") ,simple_gear:= "electrofishing",] 
gear_table[str_detect(sampling_method, "net"), simple_gear:= "netting"]
gear_table[str_detect(sampling_method, "hook"), simple_gear:= "hook and line"]
gear_table[str_detect(sampling_method, "seine"), simple_gear:= "seine"]
gear_table[str_detect(sampling_method, "weir"), simple_gear:= "weir"]
gear_table[str_detect(sampling_method, "trap"), simple_gear:= "trapping"]
gear_table[str_detect(sampling_method, "trawl"), simple_gear:= "trawling"]
gear_table[str_detect(sampling_method, "cage"), simple_gear:= "trapping"]
gear_table[sampling_method=="unknown", simple_gear:= "unknown"]
gear_table[sampling_method=="poison", simple_gear:= "other"]
gear_table[sampling_method=="setline", simple_gear:= "other"]
gear_table[sampling_method=="limbline", simple_gear:= "other"]
gear_table[sampling_method=="visual_observe", simple_gear:= "other"]
gear_table[sampling_method=="multiple_gear_types", simple_gear:= "other"]
gear_table[sampling_method=="bankpole", simple_gear:= "other"]
gear_table[sampling_method=="spearing", simple_gear:= "other"]
gear_table[sampling_method=="scuba_diving", simple_gear:= "other"]
gear_table[sampling_method=="grid", simple_gear:= "other"][]

gear_table[is.na(simple_gear), .N, ]
# all gears have been assigned a "simple gear"

#now add effort and effort units columns
#gear_table[simple_gear == "electrofishing", ':='( effort_col ="distance", effort_units_col = "distance_units")]
#gear_table[simple_gear == "netting", ':='( effort_col ="gear_data_notes.9", effort_units_col = "net_nights")][]


#join gear table back to original data
wi_inland_effort_19Mar2021[gear_table, on = "sampling_method", simple_gear:=simple_gear]
wi_inland_effort_19Mar2021[sampling_method == "fyke_net", , ]
wi_inland_effort_19Mar2021[simple_gear == "electrofishing", ':='( effort = as.character(distance), effort_units = distance_units)]
wi_inland_effort_19Mar2021[simple_gear == "netting", ':='( effort =gear_data_notes.9, effort_units = "net_nights")][]

wi_inland_effort_19Mar2021[ simple_gear == 'netting', .(effort, effort_units) , ]
```

## in future: re-write below code chunk with data.table syntax to help it run faster ## 

Merge WI fish data to effort
```{r}

### doing this with dplyr functions for now, can update to data.table later
    ### how do we want to name the effort columns so they match format from other files/states should we have sample.time 1 and 2 for minutes EF and hours nets are in or should we have total.effort.1 be distance and number of nets and total.effort.2 be minutes EF and hours nets are in..? both are important. Just need a naming scheme

# used code chunk below to check where effort lived for these gears
#wi_gear_eff_check <- wi_inland_effort_19Mar2021 %>%
#  select(gear_data_notes.11, sample_time_notes.1, sample_time_notes.3, gear_data_notes.9, sampling_method)%>%
#  filter(sampling_method %in% c("seine"))


# create effort column based upon which gear was used while retaining all original columns, not perfect, but pretty complete

    ### NOTE we should try to change the dplyr code below to data.table, maybe try "fcase" https://stackoverflow.com/questions/53031140/data-table-alternative-for-dplyr-case-when


wi_inland_effort_19Mar2021 <- wi_inland_effort_19Mar2021 %>%
  # left_join(gear_table, by = "sampling_method")%>% #join gear table SKIP HERE, ACCOMPLISHED ABOVE
  relocate(county, lake_name.1, lake_id, year, survey_id, sample_id.1, sampling_method, simple_gear, date.1, distance, distance_units, sample_time_notes.1, gear_data_notes.9, sample_time_notes.3)%>% #take these columns and put them in front
  mutate(sample_time_min = str_sub(sample_time_notes.1, 22))%>% #keep only the number of minutes
  mutate(hours_set_net = str_sub(sample_time_notes.3, 11)) %>% #keep only the number of hours nets are in
  mutate(number_of_nets = str_sub(gear_data_notes.9, 16))%>% #keep just number of nets
  mutate(distance = as.character(distance))%>% #make this a character so it can be used with other gear types
  # rename(simple_gear = simple_gear.x)%>%
  mutate(total.effort.1 = case_when(simple_gear == "electrofishing" ~ sample_time_min, #create total effort 1
                                    simple_gear == "netting" ~ hours_set_net,
                                    simple_gear == "hook and line" ~ sample_time_min,
                                    simple_gear == "seine" ~ sample_time_min,
                                    simple_gear == "trapping" ~ hours_set_net,
                                    simple_gear == "trawling" ~ sample_time_min,
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ sample_time_min,
                                    sampling_method == "scuba_diving" ~ sample_time_min,
                                    sampling_method == "spearing" ~ hours_set_net,
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ sample_time_min,
                                    sampling_method == "dip_net" ~ sample_time_min,
                                    sampling_method == "setline" ~ sample_time_min,
                                    simple_gear == "seine" ~ hours_set_net))%>%
  mutate(total.effort.2 = case_when(simple_gear == "electrofishing" ~ distance, #create total effort 2 if two relevant efforts
                                    simple_gear == "netting" ~ number_of_nets,
                                    simple_gear == "trapping" ~ number_of_nets,
                                    simple_gear == "seine" ~ number_of_nets))%>%
  mutate(total.effort.1.units = case_when(simple_gear == "electrofishing" ~ "minutes", #assign units to efforts in effort 1
                                    simple_gear == "netting" ~ "hours",
                                    simple_gear == "hook and line" ~ "minutes",
                                    simple_gear == "seine" ~ "minutes",
                                    simple_gear == "trapping" ~ "hours",
                                    simple_gear == "trawling" ~ "minutes",
                                    simple_gear == "unknown" ~ NA,
                                    simple_gear == "weir" ~ NA,
                                    sampling_method == "poison" ~ NA,
                                    sampling_method == "limbline" ~ "minutes",
                                    sampling_method == "scuba_diving" ~ "minutes",
                                    sampling_method == "spearing" ~ "hours",
                                    sampling_method == "visual_observe" ~ NA,
                                    sampling_method == "bankpole" ~ "minutes",
                                    sampling_method == "dip_net" ~ "minutes",
                                    sampling_method == "setline" ~ "minutes"))%>%
  mutate(total.effort.2.units = case_when(simple_gear == "electrofishing" ~ "miles", #assign units to efforts in effort 2
                                    simple_gear == "netting" ~ "number_of_nets",
                                    simple_gear == "trapping" ~ "number_of_traps",
                                    simple_gear == "seine" ~ "number_of_nets"))%>%
  mutate(total.effort.1 = na_if(total.effort.1, "NA"))%>% #some of the NAs from the gear_data_notes:NA aren't true NAs, change to true NA
  mutate(total.effort.2 = na_if(total.effort.2, "NA"))%>% #make character NA into true NA
  mutate(total.effort.1.units = ifelse(is.na(total.effort.1), NA, total.effort.1.units))%>% #make character NA into true NA
  mutate(total.effort.2.units = ifelse(is.na(total.effort.2), NA, total.effort.2.units)) #make character NA into true NA
  
#saveRDS(wi_inland_effort, file = "Data_and_Scripts\\Data\\output\\wi_inland_effort.rds")

# wi_effort_subset <- wi_inland_effort %>% 
#   select(county, lake_name.1, lake_id, year, survey_id, sampling_method, date.1, total.effort.1, total.effort.1.units, total.effort.2, total.effort.2.units)#subset these columns to export for later, my r is having a hard time with it
#export as a csv in case r crashes
#write_csv(wi_effort_subset, "wi_inland_effort_gear_table_10JUL2023.csv")       
  
```

Winnebago Trawl Data
- Find a unique key
- Determine effort because it is not listed in its own column
- Determine catch because it is not listed in its own column
```{r}
# date format is "POSIXct" and it won't subset properly, so first change to IDate
wi_winnebago_cpue_23Apr2021[ , date.1 := as.IDate(date.1),]

#subset by date, see if multiple trawls are done per day per site
  # are the species aggregated? Or listed once per site?
wi_winnebago_cpue_23Apr2021[ date.1 == "1986-06-11", .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1) ]
    # appears that there is one trawl per site (using all 4 IDs), species are listed once per site, so CPUE is total catch


# see if this holds true to the whole dataset
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1) ]

# Are there any instances where N > 1
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1) ] [N>1, , ]
    # YES, three instances where N > 1, what else can we add to get a unique key?

#Try adding mesh size (now named "gear_data_notes.1")
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1) ] [N>1, , ]
    # that worked! THIS IS OUR UNIQUE KEY

#check that we have the same number of rows that we started with
wi_winnebago_cpue_23Apr2021[ , .N , .(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1) ] [, , ]
      # yes we do

# are the units always "catch_per_5_min_trawl" ?
wi_winnebago_cpue_23Apr2021[ ,unique(cpue_units) , ]
    # yes! So effort is constant, always 5 minutes per trawl

# how often are notes included in the data? are they important?
wi_winnebago_cpue_23Apr2021[ ,.N, gear_data_notes.1 ]
    # hardly ever, mostly NA or 0. It is specified 4 times as an actual mesh size. 
```

Format wi_winnebago_cpue_23Apr2021 from just cpue file to a file with catch and effort listed
```{r}
# rename "cpue" column to 'total_count' to match format of other files
    # get all column names from this DT, select only the column named "cpue", rename it "total_count"

    # *note from "lake_winnebago_metadata_readme" : "-since the trawls are 5 minutes each the count values from winnebago_trawl_data.csv are simply summed to compute the cpe"
colnames(wi_winnebago_cpue_23Apr2021)[colnames(wi_winnebago_cpue_23Apr2021)=="cpue"] <- "total_count"


#add a column for effort
wi_winnebago_cpue_23Apr2021[ ,total_effort_1.1 := "5 minute trawl", ]

### would it be helpful to have it be # of fish per minute of trawl? Probably not because the trawls are always the same as is idk it's confusing in its current format
```

count up fish caught in each trawl in fish observation file and compare to fish in caught in cpue file
```{r}

wi_inland_fishobservations_19Mar2021[ , .N ,   ] 

winnebago_calc_cpue <- wi_winnebago_fishobservations_23April2021 %>%
  group_by(site_id.1, site_id.2, site_id.3, site_id.4, species.1, date.1, gear_data_notes.1)%>%
  summarise(Total_Catch = sum(total_count)) #get 49,293 unique surveys as opposed to cpue file of 48,212 surveys

#compare our calc cpue to provided cpue file

winnebago_cpue_comp <- winnebago_calc_cpue %>%
  full_join(wi_winnebago_cpue_23Apr2021[ , date.1 := as.POSIXct(date.1) ,], by = c("site_id.1", "site_id.2", "site_id.3", "site_id.4", "species.1", "date.1", "gear_data_notes.1"))%>%
  mutate(CPUE_Mismatch = ifelse(Total_Catch != total_count, paste("no_match"), paste("match")))

 # no cases where our calculated CPUE doesn't match provided CPUE %>% filter(CPUE_Mismatch == "no_match")
winnebago_cpue_comp%>%
  group_by(CPUE_Mismatch)%>%
  summarise(n())
 # 49,293 unique surveys as opposed to cpue file of 48,212 surveys, so we expect some NA values.
    49293-48212

#there is no information that we need found in the `wi_winnebago_cpue_23Apr2021` file! 
    
    rm(wi_winnebago_cpue_23Apr2021, winnebago_calc_cpue, winnebago_cpue_comp)
```

Finalize Winnebago file so individual fish observations have an effort and effort units column (should be total.effort.1 and total.effort.1.units)
```{r}
wi_winnebago_fishobservations_23April2021  <- wi_winnebago_fishobservations_23April2021 %>%
  mutate(total.effort.1 = "1")%>%
  mutate(total.effort.1.units = "5 minute trawl")%>%
  relocate(year, date.1, lake_name.1, lake_id, site_id.1, site_id.2, site_id.3, site_id.4, gear_data_notes.1, sampling_method, species.1, total_count, length.1, young_of_year, total.effort.1, total.effort.1.units, jan2023_inventoried, file_number, file_status, state, source_contact, date_recieved, source_agency, file_path, new_file_name, file_type, data_type, targeted_or_standard, individual_count, original_file_name.1, unique_row_key.1) %>% #re-order columns
uncount( weights = total_count, .remove = T, .id = "ident_uncount")






#saveRDS(wi_winnebago_fishobservations_23April2021 , file = "Data_and_Scripts\\Data\\output\\wi_winnebago_indiv_fish_w_effort.rds")
```
Winnebago is DONE

Investigate inland_fishobservations file
```{r}
wi_inland_fishobservations_19Mar2021[, .N, .(noage = is.na(age))] #no fish in this file have ages... 

wi_inland_fishobservations_19Mar2021[, .N , .(nolength = is.na(length.1))] #7 million have lengths

wi_inland_fishobservations_19Mar2021[, .N, species.1] #21 species/hybrids
```

are the aged fish also in the wi_inland_fishobservations_19Mar2021 file?
```{r}
        
#This is an issue: 


        # fish_ob_test <- wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", .N ,][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),]
        # # 650 walleye in a fyke net in this survey
        # 
        # 
        # len_age_test <- wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)]
        # # 1,137 walleye in fyke net in the same survey, but these fish have no ages, all NA..?
        # 
        #   ### in the example above, there are more fish in the length age file than the fish ob file... 
        # 
        # fish_ob_plot <- ggplot(data = fish_ob_test, aes(x = length.1))+geom_histogram(binwidth = .5)
        # len_age_plot <- ggplot(data = len_age_test, aes(x = length.1))+geom_histogram(binwidth = .5)
        # 
        # library(cowplot)
        # compare_plot <- plot_grid(fish_ob_plot, len_age_plot, labels = c("fish observations", "length age")) #same distribution of lengths
        # 
        # len_age_test[fish_ob_test, on = .(survey_id, sampling_method, species.1, lake_id, length.1, date.1),nomatch = NULL]
        # 
        # matches <- fish_ob_test[ , date.1 := as.POSIXct(date.1) ,] %>%
        #   inner_join(len_age_test, by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1"))
        # 
        # 
        # data_common1 <- generics::intersect(len_age_test, fish_ob_test)  # Apply intersect function
        # data_common1 #384 have same survey_id, sampling_method, species, lake id, length and date

# review the data from that survey (from each source):
wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", , ][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),][order(length.1)][ ,.N , length.1]
  wi_inland_fishobservations_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye", , ][,.(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age),][order(length.1)]

wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)][order(length.1)][ ,.N , length.1]
  wi_inland_lenage_19Mar2021[survey_id == "281" & sampling_method == "fyke_net" & species.1 == "walleye",  .(survey_id, sampling_method, species.1, lake_id, length.1, date.1, age)][order(length.1)]

  wi_inland_lenage_19Mar2021[ , date.1 := as.IDate(date.1) , ]
  
crosscheck <- merge(
  wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
  wi_inland_lenage_19Mar2021[ , .("laaN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
  by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1")
  )

plot(laaN~obsN, data = crosscheck[!is.na(obsN)])
abline(0,1)

crosscheck[laaN > obsN] #10k cases (N of lengthXspeciesXgearXsurvey) with more obs in laa data than in the ind fish dataset


#there are fish with backcalcualted ages (not what we want)
wi_inland_lenage_19Mar2021[,.N ,(backcalculated_age)] #yes, dp, fl

#how many ages are NAs?
wi_inland_lenage_19Mar2021[, .N,is.na(age)] #443,811 fish have ages and 239,785 fish do not have ages (35% of ages are NA)

# eliminate instances where age is NA and age was backcalculated in length age file and try a similar test as above

crosscheck <- merge(
  wi_inland_fishobservations_19Mar2021[ , .("obsN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
  wi_inland_lenage_19Mar2021[!is.na(age) & !backcalculated_age %in% c("dp", "yes", "fl")  , .("laaN" = .N), .(survey_id, sampling_method, species.1, lake_id, length.1, date.1) ],
  by = c("survey_id", "sampling_method", "species.1", "lake_id", "length.1", "date.1")
  )


ggplot(crosscheck, aes(laaN, obsN))+
  geom_point()+
  # geom_abline(slope = 1, intercept = 0)+
  scale_y_log10()

crosscheck[ , laa_subset_prop := laaN/obsN , ]

ggplot(crosscheck, aes(laa_subset_prop))+
  geom_histogram()

crosscheck[ , summary(laa_subset_prop)]

crosscheck[laaN > obsN] #eliminating the NA ages and backcalculated ages still leaves ~ 50% of the laaN>obsN data 

rm(crosscheck)

wi_inland_fishobservations_19Mar2021[ ]
colnames(wi_inland_fishobservations_19Mar2021)







```

Join wi_inland_fishobservations to the wi_inland_effort
- note, unique key is: .(lake_id, date.1, sampling_method, and sample_id.1) (year can be used too)
```{r}
#change date to IDate
wi_inland_effort_19Mar2021[ , date.1 := as.IDate(date.1,format = "%m/%d/%Y"),]

WI_indiv_fish_w_effort <- merge(wi_inland_fishobservations_19Mar2021, wi_inland_effort_19Mar2021, by = c("lake_id", "date.1", "sampling_method", "sample_id.1"), suffixes = c("_indivfish", "_effort"), all = T)

#saveRDS(WI_indiv_fish_w_effort, file = "Data_and_Scripts\\Data\\output\\wi_indiv_fish_w_effort_no_age.rds")

WI_indiv_fish_w_effort[, total_count:= 1, ]

rm(wi_inland_cpue_19Mar2021, wi_inland_effort_19Mar2021, wi_inland_fishobservations_19Mar2021)
```

*** things we may want to change about the merge above
- do we want to retain duplicate columns with suffixes? Or have them combined into a single column?
- do we want total catch at all?

Bind winnebago and inland data together
```{r}
#prep for merge


wi_winnebago_fishobservations_23April2021 [ , date.1 := as.IDate(date.1,format = "%Y/%m/%d"),]


WI_indiv_fish_w_effort <- rbindlist(list(WI_indiv_fish_w_effort, wi_winnebago_fishobservations_23April2021 ),
                               fill = TRUE,
                               use.names = TRUE)

rm(wi_winnebago_fishobservations_23April2021 )

#clean up this data product:

colnames(WI_indiv_fish_w_effort)

#county
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "county")]
WI_indiv_fish_w_effort[ county_indivfish != county_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(countyindvNA = is.na(county_indivfish), countyeffNA = is.na(county_effort)) ] 
WI_indiv_fish_w_effort[is.na(county_effort),  county_effort := county_indivfish ,  ]
WI_indiv_fish_w_effort[ , county_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "county_effort", "county")

#lake_name
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "lake_name")]
WI_indiv_fish_w_effort[ lake_name.1_indivfish != lake_name.1_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(lake_name.1_indivfish), effNA = is.na(lake_name.1_effort)) ] 
WI_indiv_fish_w_effort[is.na(lake_name.1_effort),  lake_name.1_effort := lake_name.1_indivfish ,  ]
WI_indiv_fish_w_effort[ , lake_name.1_indivfish := NULL , ]
#move effort lake_name to reg lake_name column
WI_indiv_fish_w_effort[ lake_name.1!= lake_name.1_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(lake_name.1), effNA = is.na(lake_name.1_effort) ) ] 
WI_indiv_fish_w_effort[is.na(lake_name.1),  lake_name.1 := lake_name.1_effort ,  ]
WI_indiv_fish_w_effort[ , lake_name.1_effort := NULL , ]

#year
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "year")] #what's here for year data?
#move indiv fish years to effort
WI_indiv_fish_w_effort[ year_indivfish != year_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(year_indivfish), effNA = is.na(year_effort) ) ] 
WI_indiv_fish_w_effort[is.na(year_effort),  year_effort := year_indivfish ,  ]
WI_indiv_fish_w_effort[ , year_indivfish := NULL , ]
#move effort years to reg years column
WI_indiv_fish_w_effort[ year!= year_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(year), effNA = is.na(year_effort) ) ] 
WI_indiv_fish_w_effort[is.na(year),  year := year_effort ,  ]
WI_indiv_fish_w_effort[ , year_effort := NULL , ]

#survey_id
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "survey_id")] #what's here for this var name?
#consolidate if possible
WI_indiv_fish_w_effort[ survey_id_indivfish != survey_id_effort , .N ,  ] #any disagreememnt among non-NA fields
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(survey_id_indivfish), effNA = is.na(survey_id_effort) ) ] # whats the NA coverage look like?
WI_indiv_fish_w_effort[is.na(survey_id_effort),  survey_id_effort := survey_id_indivfish ,  ]
WI_indiv_fish_w_effort[ , survey_id_indivfish := NULL , ]
setnames(WI_indiv_fish_w_effort, "survey_id_effort", "survey_id")

#survey_type.1
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "survey_type.1")] #what's here for this var name?
#consolidate if possible
WI_indiv_fish_w_effort[ survey_type.1_indivfish != survey_type.1_effort , .N ,  ] #any disagreememnt among non-NA fields
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(survey_type.1_indivfish), effNA = is.na(survey_type.1_effort) ) ] # whats the NA coverage look like?
#mostly disagreement, need to retain both. 

#state
colnames(WI_indiv_fish_w_effort)[str_detect(colnames(WI_indiv_fish_w_effort), "state")] #what's here for this var name?
#consolidate if possible
WI_indiv_fish_w_effort[ state_indivfish != state_effort , .N ,  ] #any disagreememnt among non-NA fields
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(state_indivfish), effNA = is.na(state_effort) ) ] # whats the NA coverage look like?
WI_indiv_fish_w_effort[is.na(state_effort),  state_effort := state_indivfish ,  ]
WI_indiv_fish_w_effort[ , state_indivfish := NULL , ]
#move effort years to reg years column
WI_indiv_fish_w_effort[ state!= state_effort , .N ,  ] 
WI_indiv_fish_w_effort[  , .N , .(indvNA = is.na(state), effNA = is.na(state_effort) ) ] 
WI_indiv_fish_w_effort[is.na(state),  state := state_effort ,  ]
WI_indiv_fish_w_effort[ , state_effort := NULL , ]

WI_indiv_fish_w_effort[ , unique(simple_gear) , ]



#alt approach is to include all of these in the merge. A problem with this is that if one or the other ha NA, we want to fill that void, NOT match on the NA...
#alt approach is do this before Rbind to winnebago data! That would prevent a bunch of this work. 


not_garbage <- c(
"lake_id",                       "date.1",                        "sampling_method",               "sample_id.1",                   
"county",                        "lake_name.1",                   "year",                          "survey_id",            
"species.1",                     "length.1",                      "length_unit.1",                 "weight.1",
"weight_unit.1",                 "age",                           "aging_structure",               "sex",
"young_of_year",                 "survey_type.1_indivfish",       "survey_type.2_indivfish",       "survey_type.1_effort",
"survey_type.2_effort",          "state",                         "simple_gear",                   "distance",
"distance_units",                "lat_start",                     "lon_start",                     "lat_end",
"lon_end",                       "location_notes.1",              "location_notes.2",              "location_notes.3",
"sample_time_units.1",           "sample_time_units.2",           "sample_time_units.3",           "effort_units",                  
"effort",                        "sample_time_min",               "hours_set_net",                 "number_of_nets",                 
"total.effort.1",                "total.effort.2",                "total.effort.1.units",          "total.effort.2.units",
"site_id.1",                     "site_id.2",                     "site_id.3",                     "site_id.4",


"total_count"   # Im a problem. 



"jan2023_inventoried"            "file_number"                    "file_status"                    "state"                         
"source_contact"                 "date_recieved"                  "source_agency"                  "file_path"                     
"new_file_name"                  "file_type"                      "data_type"                      "targeted_or_standard"          
"individual_count"               "original_file_name.1"           "unique_row_key.1"              
)


WI_indiv_fish_w_effort[ , .(lake_id, date.1, county, sampling 
  
)]


```




Now you can cast wide to make species matrix and add instances of 0 catch
```{r}

#this is almost certainly not sufficient as a call to widen out to surveyXgear species matrix. 
#dcast(WI_indiv_fish_w_effort, ... ~ species.1 , value.var = "total_count", fill = 0)
```


Add ages to inland fish
```{r}
colnames()

WI_indiv_fish_w_effort[ , ,   ]



````


#### Mike this is where you can merge the age data to the WI data

Below is my bad attempts at doing so

was told by Paul Frater and Alex Latzka on July 7th 2023 that the aged fish are a subset, and that primary motivation for selecting the subset is to develop age length keys
```{r}
#find unique key for the fish observations and the length age data
unique(wi_inland_fishobservations_19Mar2021, by = c("survey_id", "species.1", "sampling_method", "length.1", "date.1", "lake_id")) #not unique... check fishes without length

wi_inland_fishobservations_19Mar2021[!is.na(length.1), .N] #7,412,784 have a length, 4,968,003 do not have a length

#how about for the length and age data set
unique(wi_inland_lenage_19Mar2021, by = c("survey_id", "species.1", "sampling_method", "length.1", "date.1", "lake_id"))
wi_inland_lenage_19Mar2021[is.na(length.1), .N] #2,883 do not have a length
wi_inland_lenage_19Mar2021[is.na(age), .N]
```



```{r}

wi_inland_fishobservations_19Mar2021[ , , .(lake_id, date.1, sampling_method)]

# create a fish id number for joining purposes
wi_inland_fishobservations_19Mar2021[, id := seq_len(.N), .(lake_id, year, sampling_method, species.1)]
wi_inland_fishobservations_19Mar2021[, summary(id),] #some VERY high numbers...

#rename length column for clarity
setnames(wi_inland_fishobservations_19Mar2021, c("length.1"), c("length.fish.obs"))

setnames(wi_inland_lenage_19Mar2021, c("length.1"), c("length.fish.obs"))

wi_inland_lenage_19Mar2021[, id := seq_len(.N), .(lake_id, year, sampling_method, species.1)]
wi_inland_lenage_19Mar2021[, summary(id),]

# only getting out the same length as the length age data set... #use merge function instead
wi_inland_fishobservations_19Mar2021[wi_inland_lenage_19Mar2021, on = .(lake_id, year, sampling_method, species.1, id), all.x=TRUE]



```

